#!/usr/bin/env bash

# ═══════════════════════════════════════════════════════════════════════════
# Simple Service Manager (SSM) - 用户级服务管理器
# 版本: 5.0.0
# 许可: MIT
# ═══════════════════════════════════════════════════════════════════════════


# ═══════════════════════════════════════════════════════════════════════════
# Simple Service Manager (SSM) - 用户级服务管理器
# 更新了什么？（What's the new）
# ═══════════════════════════════════════════════════════════════════════════
#
# v5.0.0 更新摘要（喵）：
# - 新增 logs 命令（支持 tail/head 与 native/sed 后端）喵～
# - log-rotate 作为 logs 的子命令保留兼容！
# - 新增 prune / check 命令，清理与静态检查更顺手了喵～
# - start/stop/restart/reload 支持 --depends 条件执行。
# - --depends 默认仅允许 CLI 直接调用，避免脚本复杂度喵！
# - 支持 --i-don-t-care-about-anything 成为笨蛋来强制跳过 depends 检查喵～
# - install 自动处理 ssm/ssm5 名称冲突并提供覆盖选。
# - 新增 -r/--run-as（su -c）执行身份控制，命令行优先于配置喵～
# 



set -euo pipefail

# ═══════════════════════════════════════════════════════════════════════════
# 常量定义
# ═══════════════════════════════════════════════════════════════════════════

readonly SSM_VERSION="5.0.0"
readonly SSM_NAME="Simple Service Manager"

# 退出码常量
readonly EXIT_SUCCESS=0
readonly EXIT_ERROR=1
readonly EXIT_USAGE=2
readonly EXIT_PERMISSION=3
readonly EXIT_NOT_FOUND=4
readonly EXIT_ALREADY_RUNNING=5
readonly EXIT_NOT_RUNNING=6
readonly EXIT_INIT_ERROR=7
readonly EXIT_LOCK_FAILED=8
readonly EXIT_HOOK_BLOCKED=9
readonly EXIT_TWIN_ERROR=10

# 目录常量
readonly SSM_DEFAULT_ROOT="${HOME}/.services"
readonly SSM_META_DIR=".ssm"
readonly SSM_LOGS_DIR="logs"
readonly SSM_CONFIG_DIR="config"
readonly SSM_RUN_DIR="run"
readonly SSM_DATA_DIR="data"
readonly SSM_SERVICE_LOGS_DIR="services"
readonly SSM_LOCKS_DIR="locks"

# 文件名常量
readonly SSM_MANAGER_LOG="manager.log"
readonly SSM_HISTORY_LOG="history.log"
readonly SSM_MANAGER_CONF="manager.conf"
readonly SSM_SERVICE_CONF=".ssm.conf"
readonly SSM_ENABLED_SCRIPT="enabled.sh"
readonly SSM_ENABLED_HOOK_BEGIN="# >>> ssm enabled services >>>"
readonly SSM_ENABLED_HOOK_END="# <<< ssm enabled services <<<"
readonly SSM_START_SCRIPT="start.sh"
readonly SSM_PID_FILE=".pid"
readonly SSM_PID_META_FILE=".pid.meta"

# 保留名称
readonly SSM_RESERVED_NAMES=("${SSM_META_DIR}")

# 服务状态
readonly SERVICE_STATUS_RUNNING="running"
readonly SERVICE_STATUS_STOPPED="stopped"
readonly SERVICE_STATUS_DEAD="dead"
readonly SERVICE_STATUS_INVALID="invalid"

# ═══════════════════════════════════════════════════════════════════════════
# 全局变量
# ═══════════════════════════════════════════════════════════════════════════

# 当前用户
SSM_CURRENT_USER="$(whoami)"
SSM_TARGET_USER=""
SSM_TARGET_HOME=""
SSM_SERVICES_ROOT=""
SSM_RUN_AS_USER=""

CURRENT_SCRIPT_NAME="$(basename "$0")"

# 全局配置（从 manager.conf 加载）
declare -A SSM_GLOBAL_CONFIG=(
    [SSM_LOG_LEVEL]="info"
    [SSM_LOG_TIME_FORMAT]="%Y-%m-%d %H:%M:%S"
    [SSM_COLOR]="auto"
    [SSM_RUN_AS]=""
    [SSM_STOP_TIMEOUT]=10
    [SSM_START_GRACE_PERIOD]=3
    [SSM_KILL_PROCESS_GROUP]="true"
    [SSM_CHECK_PORT_BEFORE_START]="false"
    [SSM_DEFAULT_UMASK]="022"
    [SSM_DEFAULT_NICE]=0
    [SSM_CAPTURE_OUTPUT]="true"
    [SSM_OUTPUT_MODE]="separate"
    [SSM_LOG_RETENTION_DAYS]=30
    [SSM_LOG_MAX_SIZE]="50M"
    [SSM_LOG_ROTATE_KEEP]=5
    [SSM_LOG_ROTATE_COMPRESS]="true"
    [SSM_ALLOW_ROOT_SERVICES]="false"
    [SSM_STRICT_SCRIPT_PERMISSION]="true"
    [SSM_PID_FILE_MODE]="600"
    [SSM_LOCK_TIMEOUT]=30
)

# 服务配置（从服务的 .ssm.conf 加载）
declare -A SSM_SERVICE_CONFIG=(
    [SSM_SERVICE_DESCRIPTION]=""
    [SSM_SERVICE_PORT]=""
    [SSM_WORKING_DIR]=""
    [SSM_ENV_FILE]=""
    [SSM_HOOK_PRE_START]=""
    [SSM_HOOK_POST_START]=""
    [SSM_HOOK_PRE_STOP]=""
    [SSM_HOOK_POST_STOP]=""
    [SSM_HOOK_PRE_RESTART]=""
    [SSM_HOOK_POST_RESTART]=""
    [SSM_TWIN]=""
    [SSM_TWIN_START_ORDER]="twin_first"
    [SSM_TWIN_STOP_TOGETHER]="false"
    [SSM_TWIN_REQUIRE]="false"
    [SSM_ENABLE]="false"
)

# 当前处理的服务信息
SSM_CURRENT_SERVICE=""
SSM_CURRENT_SERVICE_DIR=""
SSM_CURRENT_SERVICE_PID=""

# 锁文件描述符（用于 flock）
declare -A SSM_LOCK_FDS

# 备份当前服务配置到临时关联数组
# 用法:在调用可能覆盖 SSM_SERVICE_CONFIG 的函数前调用
declare -A SSM_SERVICE_CONFIG_BACKUP

# ═══════════════════════════════════════════════════════════════════════════
# UI 框架集成（从用户提供的代码导入）
# ═══════════════════════════════════════════════════════════════════════════

# 颜色定义
readonly COLOR_RESET='\033[0m'
readonly COLOR_RED='\033[0;31m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[0;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_MAGENTA='\033[0;35m'
readonly COLOR_CYAN='\033[0;36m'
readonly COLOR_WHITE='\033[0;37m'
readonly COLOR_BOLD_RED='\033[1;31m'
readonly COLOR_BOLD_GREEN='\033[1;32m'
readonly COLOR_BOLD_YELLOW='\033[1;33m'
readonly COLOR_GRAY='\033[0;90m'

# 是否启用颜色输出
MSG_COLOR=""

# 列表分隔符样式
MSG_LIST_SEPARATOR=""

# 判断是否使用中文
# 直接根据系统 LANG 环境变量判断
function is_chinese() {
    if [[ "$LANG" =~ ^zh ]]; then
        return 0
    else
        return 1
    fi
}

# 判断是否应该使用颜色
function should_use_color() {
    case "$MSG_COLOR" in
        always)
            return 0
            ;;
        never)
            return 1
            ;;
        auto)
            # 检查是否连接到终端
            if [ -t 1 ]; then
                return 0
            else
                return 1
            fi
            ;;
        *)
            return 0
            ;;
    esac
}

# 获取终端宽度
function get_terminal_width() {
    local width
    # 尝试使用 tput
    if command -v tput &> /dev/null; then
        width=$(tput cols 2>/dev/null)
    fi
    
    # 如果 tput 失败，尝试使用 stty
    if [ -z "$width" ] || [ "$width" -eq 0 ]; then
        width=$(stty size 2>/dev/null | cut -d' ' -f2)
    fi
    
    # 如果还是失败，使用默认值
    if [ -z "$width" ] || [ "$width" -eq 0 ]; then
        width=80
    fi
    
    echo "$width"
}

# 生成分隔线
# 参数: $1 - 分隔符字符（可选）
function generate_separator() {
    local separator_char="$1"
    local terminal_width
    terminal_width=$(get_terminal_width)
    
    # 如果没有指定字符，根据样式选择
    if [ -z "$separator_char" ]; then
        case "$MSG_LIST_SEPARATOR" in
            line)
                separator_char="─"
                ;;
            dot)
                separator_char="·"
                ;;
            dash)
                separator_char="-"
                ;;
            equal)
                separator_char="="
                ;;
            wave)
                separator_char="~"
                ;;
            double)
                separator_char="═"
                ;;
            *)
                separator_char="─"
                ;;
        esac
    fi
    
    # 生成分隔线
    local separator=""
    for ((i=0; i<terminal_width; i++)); do
        separator="${separator}${separator_char}"
    done
    
    echo "$separator"
}

# 输出分隔线
# 参数: $1 - 分隔符字符（可选）
function print_separator() {
    local separator
    separator=$(generate_separator "${1:-}")
    
    if should_use_color; then
        echo -e "${COLOR_GRAY}${separator}${COLOR_RESET}"
    else
        echo "${separator}"
    fi
}

#============================================================================
# 核心消息输出函数
# 参数:
#   $1 - 消息类型 (info/success/warning/error/debug/notice)
#   $2 - 中文消息内容
#   $3 - 英文消息内容
#
# 使用示例:
#   msg "info" "这是一条信息" "This is an info message"
#   msg "error" "发生错误" "An error occurred"
#
# 环境变量控制:
#   LANG- 语言选择（系统环境变量，zh_* 为中文，其他为英文）
#   MSG_COLOR  - 颜色控制 (auto/always/never)
# ============================================================================
function msg() {
    local msg_type="$1"
    local msg_zh="$2"
    local msg_en="$3"
    
    # 根据 LANG 环境变量选择语言
    local message
    if is_chinese; then
        message="$msg_zh"
    else
        message="$msg_en"
    fi
    
    # 如果消息为空，使用另一种语言作为后备
    if [ -z "$message" ]; then
        if is_chinese; then
            message="$msg_en"
        else
            message="$msg_zh"
        fi
    fi
    
    # 定义消息类型的配置（颜色、符号前缀）
    local color prefix
    case "$msg_type" in
        info)
            color="$COLOR_BLUE"
            prefix="[-]"
            ;;
        success)
            color="$COLOR_BOLD_GREEN"
            prefix="[✓]"
            ;;
        warning)
            color="$COLOR_BOLD_YELLOW"
            prefix="[!]"
            ;;
        error)
            color="$COLOR_BOLD_RED"
            prefix="[✗]"
            ;;
        debug)
            color="$COLOR_MAGENTA"
            prefix="[•]"
            ;;
        notice)
            color="$COLOR_CYAN"
            prefix="[→]"
            ;;
        *)
            color="$COLOR_WHITE"
            prefix="[*]"
            ;;
    esac
    
    # 根据颜色设置决定是否使用颜色输出
    # 错误类型输出到stderr，其他输出到 stdout
    if [ "$msg_type" = "error" ]; then
        if should_use_color; then
            echo -e "${color}${prefix}${COLOR_RESET} ${message}" >&2
        else
            echo "${prefix} ${message}" >&2
        fi
    else
        if should_use_color; then
            echo -e "${color}${prefix}${COLOR_RESET} ${message}"
        else
            echo "${prefix} ${message}"
        fi
    fi
    
    # 始终 return 0，不因为消息类型导致 set -e 触发退出
    # 调用方应自行通过 return ${EXIT_xxx} 控制退出码
    return 0
}

# ============================================================================
# 智能列表输出函数
# 功能：根据终端宽度智能输出单列列表，元素支持多行内容
# 
# 参数:
#   $@ - 列表元素（字符串数组）
# 
# 使用示例:
#   msg_list "项目1" "项目2" "项目3"
#   msg_list "Apple" "Banana" "Cherry" "Date"
#   msg_list "这是一个很长的项目描述
#   它可以跨越多行
#   并且保持正确的格式" "项目2" "项目3"
#
#
# 样式说明:
#   line   - 实线    ─────────
#   dot    - 点线    ·········
#   dash   - 虚线    ---------
#   equal  - 双线    =========
#   wave   - 波浪线  ~~~~~~~~~
#   double - 粗线    ═════════
# ============================================================================
function msg_list() {
    # 如果没有参数，直接返回
    if [ $# -eq 0 ]; then
        return 0
    fi
    
    # 输出顶部分隔线
    print_separator
    
    # 输出每个列表项
    for item in "$@"; do
        # 直接输出元素内容，保持原有的换行和格式
        echo "$item"
    done
    
    # 输出底部分隔线
    print_separator
}

# ============================================================================
# 便捷封装函数
# ============================================================================

# 信息消息 [-]
function msg_info() {
    msg "info" "$1" "$2"
}

# 成功消息 [✓]
function msg_success() {
    msg "success" "$1" "$2"
}

# 警告消息 [!]
function msg_warning() {
    msg "warning" "$1" "$2"
}

# 错误消息 [✗]
function msg_error() {
    msg "error" "$1" "$2"
}

# 调试消息 [•]
function msg_debug() {
    msg "debug" "$1" "$2"
}

# 注意消息 [→]
function msg_notice() {
    msg "notice" "$1" "$2"
}

# 输出分隔线（便捷函数）
function msg_separator() {
    print_separator "${1:-}"
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 路径与文件
# ═══════════════════════════════════════════════════════════════════════════


function backup_service_config() {
    SSM_SERVICE_CONFIG_BACKUP=()
    local key
    for key in "${!SSM_SERVICE_CONFIG[@]}"; do
        SSM_SERVICE_CONFIG_BACKUP[$key]="${SSM_SERVICE_CONFIG[$key]}"
    done
}

# 从备份恢复服务配置
# 用法: 在调用可能覆盖 SSM_SERVICE_CONFIG 的函数后调用
function restore_service_config() {
    local key
    for key in "${!SSM_SERVICE_CONFIG_BACKUP[@]}"; do
        SSM_SERVICE_CONFIG[$key]="${SSM_SERVICE_CONFIG_BACKUP[$key]}"
    done
}


# 获取用户 HOME 目录
# 参数: $1 - 用户名
# 返回: HOME 路径
function get_user_home() {
    local username="$1"
    
    # 如果是当前用户，直接返回 $HOME
    if [[ "$username" == "$SSM_CURRENT_USER" ]]; then
        echo "$HOME"
        return 0
    fi
    
    # 否则通过 getent 获取
    local user_home
    if command -v getent &> /dev/null; then
        user_home=$(getent passwd "$username" 2>/dev/null | cut -d: -f6)
    else
        # 如果没有 getent，尝试读取 /etc/passwd
        user_home=$(grep "^${username}:" /etc/passwd 2>/dev/null | cut -d: -f6)
    fi
    
    if [[ -z "$user_home" ]]; then
        return 1
    fi
    
    echo "$user_home"
    return 0
}

# 检查用户是否存在
# 参数: $1 - 用户名
function user_exists() {
    local username="$1"
    if [[ -z "$username" ]]; then
        return 1
    fi

    if command -v id >/dev/null 2>&1; then
        if id "$username" >/dev/null 2>&1; then
            return 0
        fi
    fi

    if command -v getent >/dev/null 2>&1; then
        if getent passwd "$username" >/dev/null 2>&1; then
            return 0
        fi
    fi

    return 1
}

# 初始化目标用户环境
# 参数: $1 - 用户名（可选，默认当前用户）
function init_target_user() {
    local username="${1:-${SSM_CURRENT_USER}}"
    
    # 空字符串也使用当前用户
    if [[ -z "$username" ]]; then
        username="$SSM_CURRENT_USER"
    fi
    
    # 设置目标用户
    SSM_TARGET_USER="$username"
    
    # 获取用户 HOME 目录
    SSM_TARGET_HOME=$(get_user_home "$username")
    if [[ $? -ne 0 ]] || [[ -z "$SSM_TARGET_HOME" ]]; then
        msg_error "无法获取用户 ${username} 的 HOME 目录" "Cannot get HOME directory for user ${username}"
        return ${EXIT_ERROR}
    fi
    
    # 设置服务根目录
    SSM_SERVICES_ROOT="${SSM_TARGET_HOME}/.services"
    
    return 0
}


# 获取服务根目录
function get_services_root() {
    echo "${SSM_SERVICES_ROOT}"
}

# 获取元数据目录
function get_meta_dir() {
    echo "$(get_services_root)/${SSM_META_DIR}"
}

# 获取日志目录
function get_logs_dir() {
    echo "$(get_meta_dir)/${SSM_LOGS_DIR}"
}

# 获取服务日志目录
function get_service_logs_dir() {
    echo "$(get_logs_dir)/${SSM_SERVICE_LOGS_DIR}"
}

# 获取配置目录
function get_config_dir() {
    echo "$(get_meta_dir)/${SSM_CONFIG_DIR}"
}

# 获取运行时目录
function get_run_dir() {
    echo "$(get_meta_dir)/${SSM_RUN_DIR}"
}

# 获取锁目录
function get_locks_dir() {
    echo "$(get_run_dir)/${SSM_LOCKS_DIR}"
}

# 获取数据目录
function get_data_dir() {
    echo "$(get_meta_dir)/${SSM_DATA_DIR}"
}

# 获取服务目录
# 参数: $1 - 服务名
function get_service_dir() {
    local service_name="$1"
    echo "$(get_services_root)/${service_name}"
}

# 获取服务 PID 文件路径
# 参数: $1 - 服务名
function get_service_pid_file() {
    local service_name="$1"
    echo "$(get_service_dir "${service_name}")/${SSM_PID_FILE}"
}

# 获取服务 PID 元数据文件路径
# 参数: $1 - 服务名
function get_service_pid_meta_file() {
    local service_name="$1"
    echo "$(get_service_dir "${service_name}")/${SSM_PID_META_FILE}"
}

# 获取服务配置文件路径
# 参数: $1 - 服务名
function get_service_config_file() {
    local service_name="$1"
    echo "$(get_service_dir "${service_name}")/${SSM_SERVICE_CONF}"
}

# 获取服务启动脚本路径
# 参数: $1 - 服务名
function get_service_start_script() {
    local service_name="$1"
    echo "$(get_service_dir "${service_name}")/${SSM_START_SCRIPT}"
}

# 获取服务输出日志路径
# 参数: $1 - 服务名
function get_service_out_log() {
    local service_name="$1"
    echo "$(get_service_logs_dir)/${service_name}.out"
}

# 获取服务错误日志路径
# 参数: $1 - 服务名
function get_service_err_log() {
    local service_name="$1"
    echo "$(get_service_logs_dir)/${service_name}.err"
}

# 获取管理器日志文件路径
function get_manager_log() {
    echo "$(get_logs_dir)/${SSM_MANAGER_LOG}"
}

# 获取历史日志文件路径
function get_history_log() {
    echo "$(get_data_dir)/${SSM_HISTORY_LOG}"
}

# 获取全局配置文件路径
function get_global_config() {
    echo "$(get_config_dir)/${SSM_MANAGER_CONF}"
}

# 获取启用服务脚本路径
function get_enabled_script_file() {
    echo "$(get_meta_dir)/${SSM_ENABLED_SCRIPT}"
}

# 获取开机/会话钩子配置路径
function get_enable_hook_config_file() {
    echo "$(get_config_dir)/enable-hook.conf"
}

# 获取服务锁文件路径
# 参数: $1 - 服务名
function get_service_lock_file() {
    local service_name="$1"
    echo "$(get_locks_dir)/${service_name}.lock"
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 验证
# ═══════════════════════════════════════════════════════════════════════════

# 检查 SSM 是否已初始化
# 返回: 0=已初始化, 1=未初始化
function is_ssm_initialized() {
    local meta_dir
    meta_dir=$(get_meta_dir)
    
    # 检查元数据目录是否存在
    if [[ ! -d "$meta_dir" ]]; then
        return 1
    fi
    
    # 检查必要的子目录是否存在
    if [[ ! -d "$(get_logs_dir)" ]] || \
       [[ ! -d "$(get_config_dir)" ]] || \
       [[ ! -d "$(get_run_dir)" ]] || \
       [[ ! -d "$(get_data_dir)" ]]; then
        return 1
    fi
    
    # 检查全局配置文件是否存在
    if [[ ! -f "$(get_global_config)" ]]; then
        return 1
    fi
    
    return 0
}

# 验证服务名是否合法
# 参数: $1 - 服务名
# 返回: 0=合法, 1=非法
function validate_service_name() {
    local service_name="$1"
    
    # 检查是否为空
    if [[ -z "$service_name" ]]; then
        return 1
    fi
    
    # 检查是否以点开头
    if [[ "$service_name" =~ ^\. ]]; then
        return 1
    fi
    
    # 检查是否包含斜杠或空格
    if [[ "$service_name" =~ [/[:space:]] ]]; then
        return 1
    fi
    
    # 检查是否为保留名称
    for reserved in "${SSM_RESERVED_NAMES[@]}"; do
        if [[ "$service_name" == "$reserved" ]]; then
            return 1
        fi
    done
    
    # 检查是否只包含字母、数字、连字符、下划线
    if [[ ! "$service_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        return 1
    fi
    
    return 0
}

# 检查服务是否存在
# 参数: $1 - 服务名
# 返回: 0=存在, 1=不存在
function service_exists() {
    local service_name="$1"
    local service_dir
    service_dir=$(get_service_dir "$service_name")
    
    if [[ -e "$service_dir" ]]; then
        return 0
    else
        return 1
    fi
}

# 检查服务是否有效（有 start.sh 且可执行）
# 参数: $1 - 服务名
# 返回: 0=有效, 1=无效
function is_service_valid() {
    local service_name="$1"
    local start_script
    start_script=$(get_service_start_script "$service_name")
    
    # 检查启动脚本是否存在
    if [[ ! -f "$start_script" ]]; then
        return 1
    fi
    
    # 检查启动脚本是否可执行
    if [[ ! -x "$start_script" ]]; then
        return 1
    fi
    
    return 0
}

# 检查服务是否为符号链接
# 参数: $1 - 服务名
# 返回: 0=是链接, 1=不是链接
function is_service_link() {
    local service_name="$1"
    local service_dir
    service_dir=$(get_service_dir "$service_name")
    
    if [[ -L "$service_dir" ]]; then
        return 0
    else
        return 1
    fi
}

# 检查是否有权限操作目标用户
# 参数: $1 - 目标用户名
# 返回: 0=有权限, 1=无权限
function check_user_permission() {
    local target_user="$1"
    
    # 如果是当前用户，总是有权限
    if [[ "$target_user" == "$SSM_CURRENT_USER" ]]; then
        return 0
    fi
    
    # 如果当前是 root 用户，总是有权限
    if [[ "$SSM_CURRENT_USER" == "root" ]] || [[ "$EUID" -eq 0 ]]; then
        return 0
    fi
    
    # 否则没有权限
    return 1
}

# 检查脚本权限是否符合要求
# 参数: $1 - 脚本路径
# 返回: 0=符合, 1=不符合
function check_script_permission() {
    local script_path="$1"
    
    # 如果不要求严格权限检查，直接返回成功
    if [[ "${SSM_GLOBAL_CONFIG[SSM_STRICT_SCRIPT_PERMISSION]}" != "true" ]]; then
        return 0
    fi
    
    # 检查脚本是否存在
    if [[ ! -f "$script_path" ]]; then
        return 1
    fi
    
    # 获取脚本权限
    local perms
    perms=$(stat -c "%a" "$script_path" 2>/dev/null)
    
    # 检查是否其他用户有写权限（最后一位不能是 2, 3, 6, 7）
    local other_perm="${perms: -1}"
    if [[ "$other_perm" =~ [2367] ]]; then
        return 1
    fi
    
    return 0
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 配置管理
# ═══════════════════════════════════════════════════════════════════════════

# 加载全局配置
function load_global_config() {
    local config_file
    config_file=$(get_global_config)
    
    # 如果配置文件不存在，使用默认配置
    if [[ ! -f "$config_file" ]]; then
        return 0
    fi
    
    # 读取配置文件
    while IFS='=' read -r key value; do
        # 跳过注释和空行
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue
        
        # 去除前后空格
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        
        # 去除值的引号
        value="${value%\"}"
        value="${value#\"}"
        
        # 去除行内注释（处理 value # comment 的情况）
        # 注意：保留引号内的 # 号
        if [[ "$value" =~ ^([^#]*[^[:space:]])([[:space:]]+#.*)?$ ]]; then
            value="${BASH_REMATCH[1]}"
        fi
        
        # 再次去除尾部空格
        value=$(echo "$value" | xargs)
        
        # 更新配置
        if [[ -n "$key" ]] && [[ -n "${SSM_GLOBAL_CONFIG[$key]+x}" ]]; then
            SSM_GLOBAL_CONFIG[$key]="$value"
        fi
    done < "$config_file"
    
    return 0
}


# 保存全局配置
function save_global_config() {
    local config_file
    config_file=$(get_global_config)
    
    # 确保配置目录存在
    mkdir -p "$(get_config_dir)"
    
    # 生成配置文件（如果不存在则创建新的）
    generate_default_global_config > "$config_file"
    
    return 0
}

# 生成默认全局配置文件
function generate_default_global_config() {
    cat <<'EOF'
# ═══════════════════════════════════════════════════════════════
# SSM 全局配置
# ═══════════════════════════════════════════════════════════════

# ┌─────────────────────────────────────────────────────────────┐
# │ 基础配置                                                     │
# └─────────────────────────────────────────────────────────────┘
SSM_LOG_LEVEL="info"
SSM_LOG_TIME_FORMAT="%Y-%m-%d %H:%M:%S"
SSM_COLOR="auto"
SSM_RUN_AS=""

# ┌─────────────────────────────────────────────────────────────┐
# │ 进程管理                                                     │
# └─────────────────────────────────────────────────────────────┘
SSM_STOP_TIMEOUT=10
SSM_START_GRACE_PERIOD=3
SSM_KILL_PROCESS_GROUP=true
SSM_CHECK_PORT_BEFORE_START=false
SSM_DEFAULT_UMASK="022"
SSM_DEFAULT_NICE=0

# ┌─────────────────────────────────────────────────────────────┐
# │ 日志管理                                                     │
# └─────────────────────────────────────────────────────────────┘
SSM_CAPTURE_OUTPUT=true
SSM_OUTPUT_MODE="separate"
SSM_LOG_RETENTION_DAYS=30
SSM_LOG_MAX_SIZE="50M"
SSM_LOG_ROTATE_KEEP=5
SSM_LOG_ROTATE_COMPRESS=true

# ┌─────────────────────────────────────────────────────────────┐
# │ 安全配置                                                     │
# └─────────────────────────────────────────────────────────────┘
SSM_ALLOW_ROOT_SERVICES=false
SSM_STRICT_SCRIPT_PERMISSION=true
SSM_PID_FILE_MODE="600"

# ┌─────────────────────────────────────────────────────────────┐
# │ 并发控制                                                     │
# └─────────────────────────────────────────────────────────────┘
SSM_LOCK_TIMEOUT=30
EOF
}

# 加载服务配置
# 参数: $1 - 服务名
function load_service_config() {
    local service_name="$1"
    local config_file
    config_file=$(get_service_config_file "$service_name")
    
    # 重置服务配置为默认值
    SSM_SERVICE_CONFIG[SSM_SERVICE_DESCRIPTION]=""
    SSM_SERVICE_CONFIG[SSM_SERVICE_PORT]=""
    SSM_SERVICE_CONFIG[SSM_WORKING_DIR]=""
    SSM_SERVICE_CONFIG[SSM_ENV_FILE]=""
    SSM_SERVICE_CONFIG[SSM_HOOK_PRE_START]=""
    SSM_SERVICE_CONFIG[SSM_HOOK_POST_START]=""
    SSM_SERVICE_CONFIG[SSM_HOOK_PRE_STOP]=""
    SSM_SERVICE_CONFIG[SSM_HOOK_POST_STOP]=""
    SSM_SERVICE_CONFIG[SSM_HOOK_PRE_RESTART]=""
    SSM_SERVICE_CONFIG[SSM_HOOK_POST_RESTART]=""
    SSM_SERVICE_CONFIG[SSM_TWIN]=""
    SSM_SERVICE_CONFIG[SSM_TWIN_START_ORDER]="twin_first"
    SSM_SERVICE_CONFIG[SSM_TWIN_STOP_TOGETHER]="false"
    SSM_SERVICE_CONFIG[SSM_TWIN_REQUIRE]="false"
    SSM_SERVICE_CONFIG[SSM_ENABLE]="false"
    
    # 如果配置文件不存在，返回
    if [[ ! -f "$config_file" ]]; then
        return 0
    fi
    
    # 读取配置文件
    while IFS='=' read -r key value; do
        # 跳过注释和空行
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue
        
        # 去除前后空格
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        
        # 去除值的引号
        value="${value%\"}"
        value="${value#\"}"
        
        # 去除行内注释（处理 value # comment 的情况）
        # 注意：保留引号内的 # 号
        if [[ "$value" =~ ^([^#]*[^[:space:]])([[:space:]]+#.*)?$ ]]; then
            value="${BASH_REMATCH[1]}"
        fi
        
        # 再次去除尾部空格
        value=$(echo "$value" | xargs)
        
        # 只更新服务配置（不修改全局配置）
        if [[ -n "$key" ]] && [[ -n "${SSM_SERVICE_CONFIG[$key]+x}" ]]; then
            SSM_SERVICE_CONFIG[$key]="$value"
        fi
    done < "$config_file"
    
    return 0
}


# 保存服务配置
# 参数: $1 - 服务名
function save_service_config() {
    local service_name="$1"
    local config_file
    config_file=$(get_service_config_file "$service_name")
    local service_dir
    service_dir=$(get_service_dir "$service_name")
    
    # 生成配置文件
    generate_default_service_config "$service_dir" > "$config_file"
    
    return 0
}

# 生成默认服务配置文件
# 参数: $1 - 服务目录
function generate_default_service_config() {
    local service_dir="$1"
    
    cat <<'EOF'
# ═══════════════════════════════════════════════════════════════
# 服务配置 - 覆盖全局配置
# ═══════════════════════════════════════════════════════════════

# ┌─────────────────────────────────────────────────────────────┐
# │ 服务信息                                                     │
# └─────────────────────────────────────────────────────────────┘
SSM_SERVICE_DESCRIPTION=""
SSM_SERVICE_PORT=""

# ┌─────────────────────────────────────────────────────────────┐
# │ 运行环境                                                     │
# └─────────────────────────────────────────────────────────────┘
SSM_WORKING_DIR=""
SSM_ENV_FILE=""

# ┌─────────────────────────────────────────────────────────────┐
# │ 钩子脚本                                                     │
# └─────────────────────────────────────────────────────────────┘
SSM_HOOK_PRE_START=""
SSM_HOOK_POST_START=""
SSM_HOOK_PRE_STOP=""
SSM_HOOK_POST_STOP=""
SSM_HOOK_PRE_RESTART=""
SSM_HOOK_POST_RESTART=""

# ┌─────────────────────────────────────────────────────────────┐
# │ 双生子                                                       │
# └─────────────────────────────────────────────────────────────┘
SSM_TWIN=""
SSM_TWIN_START_ORDER="twin_first"
SSM_TWIN_STOP_TOGETHER=false
SSM_TWIN_REQUIRE=false

# ┌─────────────────────────────────────────────────────────────┐
# │ 启用状态（自动启动）                                         │
# └─────────────────────────────────────────────────────────────┘
SSM_ENABLE=false
EOF
}

# 获取配置值（服务配置优先，然后是全局配置）
# 参数: $1 - 配置键
# 返回: 配置值
function get_config_value() {
    local key="$1"
    
    # 优先从服务配置获取（仅服务专属配置）
    if [[ -n "${SSM_SERVICE_CONFIG[$key]+x}" ]] && [[ -n "${SSM_SERVICE_CONFIG[$key]}" ]]; then
        echo "${SSM_SERVICE_CONFIG[$key]}"
        return 0
    fi
    
    # 从全局配置获取
    if [[ -n "${SSM_GLOBAL_CONFIG[$key]+x}" ]]; then
        echo "${SSM_GLOBAL_CONFIG[$key]}"
        return 0
    fi
    
    # 都没有则返回空
    echo ""
    return 1
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 进程管理
# ═══════════════════════════════════════════════════════════════════════════

# 读取服务 PID
# 参数: $1 - 服务名
# 返回: PID 或空
function read_service_pid() {
    local service_name="$1"
    local pid_file
    pid_file=$(get_service_pid_file "$service_name")
    
    if [[ ! -f "$pid_file" ]]; then
        echo ""
        return 1
    fi
    
    local pid
    if ! IFS= read -r pid < "$pid_file"; then
        echo ""
        return 1
    fi
    
    # 验证 PID 是否为数字
    if [[ ! "$pid" =~ ^[0-9]+$ ]]; then
        echo ""
        return 1
    fi
    
    echo "$pid"
    return 0
}

# 读取进程启动时间（/proc/<pid>/stat 第22列，单位 jiffies）
# 参数: $1 - PID
# 返回: 启动时间或空
function get_process_start_ticks() {
    local pid="$1"

    if [[ -z "$pid" ]] || [[ ! "$pid" =~ ^[0-9]+$ ]]; then
        echo ""
        return 1
    fi

    if [[ ! -f "/proc/$pid/stat" ]]; then
        echo ""
        return 1
    fi

    local ticks
    ticks=$(awk '{print $22}' "/proc/$pid/stat" 2>/dev/null || true)
    if [[ -z "$ticks" ]] || [[ ! "$ticks" =~ ^[0-9]+$ ]]; then
        echo ""
        return 1
    fi

    echo "$ticks"
    return 0
}

# 读取服务 PID 元数据中的启动时间
# 参数: $1 - 服务名
# 返回: start_ticks 或空
function read_service_pid_start_ticks() {
    local service_name="$1"
    local meta_file
    meta_file=$(get_service_pid_meta_file "$service_name")

    if [[ ! -f "$meta_file" ]]; then
        echo ""
        return 1
    fi

    local line
    while IFS= read -r line; do
        if [[ "$line" =~ ^START_TICKS=([0-9]+)$ ]]; then
            echo "${BASH_REMATCH[1]}"
            return 0
        fi
    done < "$meta_file"

    echo ""
    return 1
}

# 写入服务 PID
# 参数: $1 - 服务名, $2 - PID
function write_service_pid() {
    local service_name="$1"
    local pid="$2"
    local pid_file
    pid_file=$(get_service_pid_file "$service_name")
    local meta_file
    meta_file=$(get_service_pid_meta_file "$service_name")
    
    echo "$pid" > "$pid_file"
    
    # 设置 PID 文件权限
    local mode="${SSM_GLOBAL_CONFIG[SSM_PID_FILE_MODE]}"
    chmod "$mode" "$pid_file" 2>/dev/null || true

    # 写入 PID 元数据（用于避免 PID 复用误判）
    local start_ticks
    start_ticks=$(get_process_start_ticks "$pid" 2>/dev/null || true)
    if [[ -n "$start_ticks" ]]; then
        {
            echo "PID=${pid}"
            echo "START_TICKS=${start_ticks}"
        } > "$meta_file"
        chmod "$mode" "$meta_file" 2>/dev/null || true
    else
        rm -f "$meta_file" 2>/dev/null || true
    fi
    
    return 0
}

# 删除服务 PID 文件
# 参数: $1 - 服务名
function remove_service_pid() {
    local service_name="$1"
    local pid_file
    pid_file=$(get_service_pid_file "$service_name")
    local meta_file
    meta_file=$(get_service_pid_meta_file "$service_name")
    
    if [[ -f "$pid_file" ]]; then
        rm -f "$pid_file"
    fi

    if [[ -f "$meta_file" ]]; then
        rm -f "$meta_file"
    fi
    
    return 0
}

# 检查 PID 是否仍然是同一个进程（通过启动时间判断，防止 PID 复用）
# 参数: $1 - 服务名, $2 - PID
# 返回: 0=同一进程, 1=不是同一进程
function is_same_service_process() {
    local service_name="$1"
    local pid="$2"

    if [[ -z "$pid" ]] || [[ ! "$pid" =~ ^[0-9]+$ ]]; then
        return 1
    fi

    if ! is_process_alive "$pid"; then
        return 1
    fi

    local saved_ticks
    saved_ticks=$(read_service_pid_start_ticks "$service_name" 2>/dev/null || true)

    # 兼容老版本 .pid（没有 meta 文件时维持原行为）
    if [[ -z "$saved_ticks" ]]; then
        return 0
    fi

    local current_ticks
    current_ticks=$(get_process_start_ticks "$pid" 2>/dev/null || true)
    if [[ -z "$current_ticks" ]]; then
        return 1
    fi

    if [[ "$saved_ticks" == "$current_ticks" ]]; then
        return 0
    fi

    return 1
}

# 检查进程是否存活
# 参数: $1 - PID
# 返回: 0=存活, 1=不存活
function is_process_alive() {
    local pid="$1"
    
    # 检查 PID 是否为空
    if [[ -z "$pid" ]]; then
        return 1
    fi
    
    # 使用 kill -0 检查进程是否存在
    if kill -0 "$pid" 2>/dev/null; then
        return 0
    else
        return 1
    fi
}

# 检查服务是否运行中
# 参数: $1 - 服务名
# 返回: 0=运行中, 1=未运行
function is_service_running() {
    local service_name="$1"
    
    # 读取 PID
    local pid
    pid=$(read_service_pid "$service_name")
    
    if [[ -z "$pid" ]]; then
        return 1
    fi
    
    # 检查进程是否存活且与 PID 文件匹配
    if is_same_service_process "$service_name" "$pid"; then
        return 0
    else
        return 1
    fi
}

# 获取服务状态
# 参数: $1 - 服务名
# 返回: running/stopped/dead/invalid
function get_service_status() {
    local service_name="$1"
    
    # 检查服务是否有效
    if ! is_service_valid "$service_name"; then
        echo "$SERVICE_STATUS_INVALID"
        return 0
    fi
    
    # 读取 PID
    local pid
    pid=$(read_service_pid "$service_name")
    
    if [[ -z "$pid" ]]; then
        echo "$SERVICE_STATUS_STOPPED"
        return 0
    fi
    
    # 检查进程是否存活且与 PID 文件匹配
    if is_same_service_process "$service_name" "$pid"; then
        echo "$SERVICE_STATUS_RUNNING"
    else
        echo "$SERVICE_STATUS_DEAD"
    fi
    
    return 0
}

# 获取进程运行时长
# 参数: $1 - PID
# 返回: 运行时长字符串（如 "2d 3h 45m"）
function get_process_uptime() {
    local pid="$1"
    
    # 检查进程是否存在
    if ! is_process_alive "$pid"; then
        echo "-"
        return 1
    fi
    
    # 获取进程启动时间（从 /proc 获取）
    if [[ ! -f "/proc/$pid/stat" ]]; then
        echo "-"
        return 1
    fi
    
    # 读取进程启动时间（单位：jiffies）
    local start_time
    start_time=$(awk '{print $22}' "/proc/$pid/stat" 2>/dev/null)
    
    if [[ -z "$start_time" ]]; then
        echo "-"
        return 1
    fi
    
    # 获取系统启动时间
    local boot_time
    boot_time=$(awk '/btime/ {print $2}' /proc/stat 2>/dev/null)
    
    if [[ -z "$boot_time" ]]; then
        echo "-"
        return 1
    fi
    
    # 获取 clock ticks per second
    local hz
    hz=$(getconf CLK_TCK 2>/dev/null || echo 100)
    
    # 计算进程启动的绝对时间
    local process_start_time
    process_start_time=$((boot_time + start_time / hz))
    
    # 获取当前时间
    local current_time
    current_time=$(date +%s)
    
    # 计算运行时长（秒）
    local uptime_seconds
    uptime_seconds=$((current_time - process_start_time))
    
    # 格式化输出
    local days=$((uptime_seconds / 86400))
    local hours=$(((uptime_seconds % 86400) / 3600))
    local minutes=$(((uptime_seconds % 3600) / 60))
    
    if [[ $days -gt 0 ]]; then
        echo "${days}d ${hours}h"
    elif [[ $hours -gt 0 ]]; then
        echo "${hours}h ${minutes}m"
    else
        echo "${minutes}m"
    fi
    
    return 0
}

# 停止进程
# 参数: $1 - PID, $2 - 超时时间（秒）
# 返回: 0=成功, 1=失败
function stop_process() {
    local pid="$1"
    local timeout="$2"
    
    # 检查进程是否存在
    if ! is_process_alive "$pid"; then
        return 0
    fi
    
    # 发送 SIGTERM
    kill -TERM "$pid" 2>/dev/null || true
    
    # 等待进程退出
    local waited=0
    while [[ $waited -lt $timeout ]]; do
        if ! is_process_alive "$pid"; then
            return 0
        fi
        sleep 1
        waited=$((waited + 1))
    done
    
    # 超时后发送 SIGKILL
    if is_process_alive "$pid"; then
        kill -KILL "$pid" 2>/dev/null || true
        sleep 1
        
        # 再次检查
        if is_process_alive "$pid"; then
            return 1
        fi
    fi
    
    return 0
}

# 停止进程组
# 参数: $1 - PID, $2 - 超时时间（秒）
# 返回: 0=成功, 1=失败
function stop_process_group() {
    local pid="$1"
    local timeout="$2"
    
    # 检查进程是否存在
    if ! is_process_alive "$pid"; then
        return 0
    fi
    
    # 获取进程组 ID
    local pgid
    pgid=$(ps -o pgid= -p "$pid" 2>/dev/null | tr -d ' ')
    
    if [[ -z "$pgid" ]]; then
        # 如果无法获取进程组，回退到单进程停止
        stop_process "$pid" "$timeout"
        return $?
    fi
    
    # 发送 SIGTERM 到整个进程组
    kill -TERM -"$pgid" 2>/dev/null || true
    
    # 等待进程退出
    local waited=0
    while [[ $waited -lt $timeout ]]; do
        if ! is_process_alive "$pid"; then
            return 0
        fi
        sleep 1
        waited=$((waited + 1))
    done
    
    # 超时后发送 SIGKILL 到整个进程组
    if is_process_alive "$pid"; then
        kill -KILL -"$pgid" 2>/dev/null || true
        sleep 1
        
        # 再次检查
        if is_process_alive "$pid"; then
            return 1
        fi
    fi
    
    return 0
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 环境变量文件管理
# ═══════════════════════════════════════════════════════════════════════════

# 获取服务环境变量文件路径
# 参数: $1 - 服务名
# 返回: .ssm.env 文件路径
function get_service_env_file() {
    local service_name="$1"
    echo "$(get_service_dir "${service_name}")/.ssm.env"
}

# 检查环境变量文件是否存在
# 参数: $1 - 服务名
# 返回: 0=存在, 1=不存在
function has_env_file() {
    local service_name="$1"
    local env_file
    env_file=$(get_service_env_file "$service_name")
    
    if [[ -f "$env_file" ]]; then
        return 0
    else
        return 1
    fi
}

# 保存环境变量到文件
# 参数: $1 - 服务名, $2 - 主服务环境变量, $3 - 伴生服务环境变量（可选）
# 返回: 0=成功, 1=失败
function save_env_to_file() {
    local service_name="$1"
    local main_env="$2"
    local twin_env="${3:-}"
    
    local env_file
    env_file=$(get_service_env_file "$service_name")
    
    # 转义单引号：将 ' 替换为 '\''
    local main_escaped="${main_env//\'/\'\\\'\'}"
    local twin_escaped="${twin_env//\'/\'\\\'\'}"
    
    # 生成时间戳
    local timestamp
    timestamp=$(date +"${SSM_GLOBAL_CONFIG[SSM_LOG_TIME_FORMAT]}")
    
    # 写入文件
    cat > "$env_file" <<EOF
#!/usr/bin/env bash
# .ssm.env - SSM 命令行环境变量记录
# 此文件由 SSM 自动管理，请勿手动编辑
# 生成时间: ${timestamp}
# 服务名称: ${service_name}

# 主服务环境变量
SSM_MAIN='${main_escaped}'
EOF
    
    # 如果有伴生服务环境变量，追加
    if [[ -n "$twin_env" ]]; then
        cat >> "$env_file" <<EOF

# 伴生服务环境变量
SSM_TWIN='${twin_escaped}'
EOF
    fi
    
    # 设置权限为 600（只有所有者可读写）
    if ! chmod 600 "$env_file" 2>/dev/null; then
        msg_warning "无法设置环境变量文件权限" "Cannot set permissions on env file"
        # 不返回失败，继续执行
    fi
    
    return 0
}

# 从文件读取环境变量
# 参数: $1 - 服务名
# 输出: 设置全局变量 SSM_MAIN 和 SSM_TWIN
# 返回: 0=成功或文件不存在, 1=读取失败
function load_env_from_file() {
    local service_name="$1"
    local env_file
    env_file=$(get_service_env_file "$service_name")
    
    # 初始化为空
    SSM_MAIN=""
    SSM_TWIN=""
    
    # 如果文件不存在，返回成功（空值）
    if [[ ! -f "$env_file" ]]; then
        return 0
    fi
    
    # 检查文件权限（警告但不阻止）
    local perms
    perms=$(stat -c "%a" "$env_file" 2>/dev/null)
    if [[ -n "$perms" ]] && [[ "$perms" != "600" ]]; then
        msg_warning ".ssm.env 文件权限不安全: ${perms}，建议 600" \
                    ".ssm.env file has insecure permissions: ${perms}, recommended 600"
    fi
    
    # 逐行解析（不使用 source，避免执行任意代码）
    local line
    local parse_ok=true

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        [[ "$line" =~ ^[[:space:]]*# ]] && continue

        if [[ "$line" =~ ^SSM_MAIN='(.*)'$ ]]; then
            SSM_MAIN="${BASH_REMATCH[1]}"
            SSM_MAIN="${SSM_MAIN//\'\\\'\'/\'}"
            continue
        fi

        if [[ "$line" =~ ^SSM_TWIN='(.*)'$ ]]; then
            SSM_TWIN="${BASH_REMATCH[1]}"
            SSM_TWIN="${SSM_TWIN//\'\\\'\'/\'}"
            continue
        fi

        # 允许 shebang，其余未知语句视为文件损坏
        if [[ "$line" =~ ^#! ]]; then
            continue
        fi

        parse_ok=false
        break
    done < "$env_file"

    if [[ "$parse_ok" != "true" ]]; then
        msg_warning "读取环境变量文件失败，文件可能已损坏: ${env_file}" \
                    "Failed to read env file, file may be corrupted: ${env_file}"
        msg_info "将忽略环境变量文件" "Will ignore env file"
        SSM_MAIN=""
        SSM_TWIN=""
        return 1
    fi

    return 0
}

# 删除环境变量文件
# 参数: $1 - 服务名
# 返回: 0=成功, 1=失败（但不影响流程）
function remove_env_file() {
    local service_name="$1"
    local env_file
    env_file=$(get_service_env_file "$service_name")
    
    # 如果文件不存在，直接返回成功
    if [[ ! -f "$env_file" ]]; then
        return 0
    fi
    
    # 删除文件
    if rm -f "$env_file" 2>/dev/null; then
        return 0
    else
        msg_warning "无法删除环境变量文件: ${env_file}" \
                    "Cannot remove env file: ${env_file}"
        return 1
    fi
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 锁管理
# ═══════════════════════════════════════════════════════════════════════════

# 获取服务锁
# 参数: $1 - 服务名, $2 - 超时时间（秒）
# 返回: 0=成功, 1=失败
function acquire_service_lock() {
    local service_name="$1"
    local timeout="$2"
    local lock_file
    lock_file=$(get_service_lock_file "$service_name")
    
    # 确保锁目录存在
    mkdir -p "$(get_locks_dir)"
    
    # 尝试获取锁
    local fd
    exec {fd}>"$lock_file"
    
    # 使用 flock 获取锁
    if flock -w "$timeout" "$fd"; then
        # 保存文件描述符
        SSM_LOCK_FDS["$service_name"]="$fd"
        return 0
    else
        # 获取锁失败，关闭文件描述符
        exec {fd}>&-
        return 1
    fi
}

# 释放服务锁
# 参数: $1 - 服务名
function release_service_lock() {
    local service_name="$1"
    
    # 检查是否有锁
    if [[ -z "${SSM_LOCK_FDS[$service_name]+x}" ]]; then
        return 0
    fi
    
    local fd="${SSM_LOCK_FDS[$service_name]}"
    
    # 释放锁并关闭文件描述符
    flock -u "$fd" 2>/dev/null || true
    exec {fd}>&-
    
    # 从数组中删除
    unset SSM_LOCK_FDS["$service_name"]
    
    return 0
}

# 释放主服务及伴生服务锁
# 参数: $1 - 主服务名, $2 - 伴生服务名（可选）
function release_related_locks() {
    local main_service="$1"
    local twin_service="${2:-}"

    if [[ -n "$main_service" ]]; then
        release_service_lock "$main_service"
    fi
    if [[ -n "$twin_service" ]]; then
        release_service_lock "$twin_service"
    fi

    return 0
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 钩子管理
# ═══════════════════════════════════════════════════════════════════════════

# 执行钩子脚本
# 参数: $1 - 钩子名称, $2 - 服务名
# 返回: 钩子脚本的退出码
function execute_hook() {
    local hook_name="$1"
    local service_name="$2"
    
    # 获取钩子路径
    local hook_path
    case "$hook_name" in
        pre-start)
            hook_path="${SSM_SERVICE_CONFIG[SSM_HOOK_PRE_START]}"
            ;;
        post-start)
            hook_path="${SSM_SERVICE_CONFIG[SSM_HOOK_POST_START]}"
            ;;
        pre-stop)
            hook_path="${SSM_SERVICE_CONFIG[SSM_HOOK_PRE_STOP]}"
            ;;
        post-stop)
            hook_path="${SSM_SERVICE_CONFIG[SSM_HOOK_POST_STOP]}"
            ;;
        pre-restart)
            hook_path="${SSM_SERVICE_CONFIG[SSM_HOOK_PRE_RESTART]}"
            ;;
        post-restart)
            hook_path="${SSM_SERVICE_CONFIG[SSM_HOOK_POST_RESTART]}"
            ;;
        *)
            return 0
            ;;
    esac
    
    # 如果钩子路径为空，直接返回成功
    if [[ -z "$hook_path" ]]; then
        return 0
    fi
    
    # 获取服务目录（必须提供服务名）
    if [[ -z "$service_name" ]]; then
        msg_warning "执行钩子失败：未提供服务名" "Failed to execute hook: no service name provided"
        return 0
    fi
    
    local service_dir
    service_dir=$(get_service_dir "$service_name")
    
    # 如果不是绝对路径，转换为相对于服务目录的路径
    if [[ "$hook_path" != /* ]]; then
        hook_path="${service_dir}/${hook_path}"
    fi
    
    # 检查钩子是否存在且可执行
    if [[ ! -f "$hook_path" ]]; then
        msg_warning "钩子脚本不存在: ${hook_path}" "Hook script does not exist: ${hook_path}"
        return 0
    fi
    
    if [[ ! -x "$hook_path" ]]; then
        msg_warning "钩子脚本不可执行: ${hook_path}" "Hook script is not executable: ${hook_path}"
        return 0
    fi
    
    # 检查脚本权限（如果启用了严格权限检查）
    if ! check_script_permission "$hook_path"; then
        msg_warning "钩子脚本权限不安全（其他用户有写权限）: ${hook_path}" \
                    "Hook script has insecure permissions (writable by others): ${hook_path}"
        # 严格模式下拒绝执行
        if [[ "${SSM_GLOBAL_CONFIG[SSM_STRICT_SCRIPT_PERMISSION]}" == "true" ]]; then
            msg_error "钩子脚本权限检查失败" "Hook script permission check failed"
            return 1
        fi
    fi
    
    # 设置环境变量
    export SSM_SERVICE_NAME="$service_name"
    export SSM_SERVICE_DIR="$service_dir"
    export SSM_SERVICE_PID="$(read_service_pid "$service_name" 2>/dev/null || echo "")"
    export SSM_ACTION="${hook_name%%-*}"  # start, stop, restart
    export SSM_HOOK="$hook_name"
    
    # 执行钩子
    local exit_code
    "$hook_path"
    exit_code=$?
    
    # 清理环境变量
    unset SSM_SERVICE_NAME SSM_SERVICE_DIR SSM_SERVICE_PID SSM_ACTION SSM_HOOK
    
    return $exit_code
}


# 检查钩子是否存在
# 参数: $1 - 钩子路径
# 返回: 0=存在, 1=不存在
function hook_exists() {
    local hook_path="$1"
    
    # 如果路径为空，返回不存在
    if [[ -z "$hook_path" ]]; then
        return 1
    fi
    
    # 如果不是绝对路径，转换为相对于服务目录的路径
    if [[ "$hook_path" != /* ]]; then
        local service_dir
        service_dir=$(get_service_dir "$SSM_CURRENT_SERVICE")
        hook_path="${service_dir}/${hook_path}"
    fi
    
    # 检查文件是否存在且可执行
    if [[ -f "$hook_path" ]] && [[ -x "$hook_path" ]]; then
        return 0
    else
        return 1
    fi
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 双生子管理
# ═══════════════════════════════════════════════════════════════════════════

# 获取服务的双生子
# 参数: $1 - 服务名
# 返回: 双生子服务名或空
function get_service_twin() {
    local service_name="$1"
    
    # 加载服务配置
    load_service_config "$service_name"
    
    # 返回双生子名称
    echo "${SSM_SERVICE_CONFIG[SSM_TWIN]}"
}

# 验证双生子配置
# 参数: $1 - 主服务名
# 返回: 0=配置有效, 1=配置无效（双向配置）
function validate_twin_config() {
    local main_service="$1"
    
    # 获取主服务的双生子
    local twin_service
    twin_service=$(get_service_twin "$main_service")
    
    # 如果没有双生子，配置有效
    if [[ -z "$twin_service" ]]; then
        return 0
    fi
    
    # 检查伴生服务是否存在
    if ! service_exists "$twin_service"; then
        return 1
    fi
    
    # 获取伴生服务的双生子
    local twin_of_twin
    twin_of_twin=$(get_service_twin "$twin_service")
    
    # 如果伴生服务也配置了双生子，配置无效
    if [[ -n "$twin_of_twin" ]]; then
        return 1
    fi
    
    return 0
}

# 获取双生子启动顺序
# 参数: $1 - 服务名
# 返回: twin_first/main_first
function get_twin_start_order() {
    local service_name="$1"
    
    # 加载服务配置
    load_service_config "$service_name"
    
    # 返回启动顺序
    local order="${SSM_SERVICE_CONFIG[SSM_TWIN_START_ORDER]}"
    
    # 验证值
    if [[ "$order" == "twin_first" ]] || [[ "$order" == "main_first" ]]; then
        echo "$order"
    else
        echo "twin_first"
    fi
}

# 检查是否需要连带停止双生子
# 参数: $1 - 服务名
# 返回: 0=需要, 1=不需要
function should_stop_twin_together() {
    local service_name="$1"
    
    # 加载服务配置
    load_service_config "$service_name"
    
    # 检查配置
    if [[ "${SSM_SERVICE_CONFIG[SSM_TWIN_STOP_TOGETHER]}" == "true" ]]; then
        return 0
    else
        return 1
    fi
}

# 检查双生子是否为必需
# 参数: $1 - 服务名
# 返回: 0=必需, 1=非必需
function is_twin_required() {
    local service_name="$1"
    
    # 加载服务配置
    load_service_config "$service_name"
    
    # 检查配置
    if [[ "${SSM_SERVICE_CONFIG[SSM_TWIN_REQUIRE]}" == "true" ]]; then
        return 0
    else
        return 1
    fi
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 日志管理
# ═══════════════════════════════════════════════════════════════════════════

# 写入管理器日志
# 参数: $1 - 日志级别, $2 - 消息
function log_manager() {
    local level="$1"
    local message="$2"
    local log_file
    log_file=$(get_manager_log)
    
    # 确保日志目录存在
    mkdir -p "$(get_logs_dir)"
    
    # 获取时间格式
    local time_format="${SSM_GLOBAL_CONFIG[SSM_LOG_TIME_FORMAT]}"
    local timestamp
    timestamp=$(date +"$time_format")
    
    # 写入日志
    echo "[${timestamp}] [${level}] ${message}" >> "$log_file"
    
    return 0
}

# 写入历史记录
# 参数: $1 - 动作, $2 - 服务名, $3 - 状态, $4 - 详情
function log_history() {
    local action="$1"
    local service_name="$2"
    local status="$3"
    local details="$4"
    local history_file
    history_file=$(get_history_log)
    
    # 确保数据目录存在
    mkdir -p "$(get_data_dir)"
    
    # 获取时间格式
    local time_format="${SSM_GLOBAL_CONFIG[SSM_LOG_TIME_FORMAT]}"
    local timestamp
    timestamp=$(date +"$time_format")
    
    # 格式化动作（固定宽度）
    local action_formatted
    action_formatted=$(printf "%-8s" "$action")
    
    # 写入历史
    echo "${timestamp} | ${action_formatted} | ${service_name} | ${status} | ${details}" >> "$history_file"
    
    return 0
}

# 轮转日志文件
# 参数: $1 - 日志文件路径
function rotate_log_file() {
    local log_file="$1"
    
    # 检查日志文件是否存在
    if [[ ! -f "$log_file" ]]; then
        return 0
    fi
    
    # 获取配置
    local max_size="${SSM_GLOBAL_CONFIG[SSM_LOG_MAX_SIZE]}"
    local keep_count="${SSM_GLOBAL_CONFIG[SSM_LOG_ROTATE_KEEP]}"
    local compress="${SSM_GLOBAL_CONFIG[SSM_LOG_ROTATE_COMPRESS]}"
    
    # 转换大小单位（支持 K/k, M/m, G/g）
    local max_size_bytes
    if [[ "$max_size" =~ ^([0-9]+)([KMGkmg]?)$ ]]; then
        local num="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        
        # 转换为大写
        unit=$(echo "$unit" | tr '[:lower:]' '[:upper:]')
        
        case "$unit" in
            K)
                max_size_bytes=$((num * 1024))
                ;;
            M)
                max_size_bytes=$((num * 1024 * 1024))
                ;;
            G)
                max_size_bytes=$((num * 1024 * 1024 * 1024))
                ;;
            "")
                # 没有单位，直接当作字节数
                max_size_bytes=$num
                ;;
            *)
                msg_warning "无效的日志大小单位: ${unit}，使用默认值" "Invalid log size unit: ${unit}, using default"
                max_size_bytes=$((50 * 1024 * 1024))  # 默认 50M
                ;;
        esac
    else
        msg_warning "无效的日志大小格式: ${max_size}，使用默认值" "Invalid log size format: ${max_size}, using default"
        max_size_bytes=$((50 * 1024 * 1024))  # 默认 50M
    fi
    
    # 获取当前文件大小
    local current_size
    current_size=$(stat -c%s "$log_file" 2>/dev/null || echo 0)
    
    # 如果文件大小未超过限制，不需要轮转
    if [[ $current_size -lt $max_size_bytes ]]; then
        return 0
    fi
    
    # 删除最旧的轮转文件
    local oldest_index=$((keep_count - 1))
    if [[ "$compress" == "true" ]]; then
        rm -f "${log_file}.${oldest_index}.gz" 2>/dev/null || true
    else
        rm -f "${log_file}.${oldest_index}" 2>/dev/null || true
    fi
    
    # 轮转现有文件（从旧到新）
    for ((i=oldest_index-1; i>=0; i--)); do
        local next=$((i + 1))
        if [[ "$compress" == "true" ]]; then
            if [[ -f "${log_file}.${i}.gz" ]]; then
                mv "${log_file}.${i}.gz" "${log_file}.${next}.gz" 2>/dev/null || true
            fi
        else
            if [[ -f "${log_file}.${i}" ]]; then
                mv "${log_file}.${i}" "${log_file}.${next}" 2>/dev/null || true
            fi
        fi
    done
    
    # 轮转当前日志文件
    if [[ "$compress" == "true" ]]; then
        # 使用 gzip 压缩
        if command -v gzip &> /dev/null; then
            gzip -c "$log_file" > "${log_file}.0.gz" 2>/dev/null || {
                msg_warning "日志压缩失败，直接复制" "Log compression failed, copying instead"
                cp "$log_file" "${log_file}.0" 2>/dev/null || true
            }
        else
            msg_warning "gzip 命令不可用，不压缩日志" "gzip not available, not compressing logs"
            cp "$log_file" "${log_file}.0" 2>/dev/null || true
        fi
    else
        cp "$log_file" "${log_file}.0" 2>/dev/null || true
    fi
    
    # 清空当前日志文件（保留 inode，避免影响正在写入的进程）
    : > "$log_file"
    
    return 0
}

# 清理过期日志
function cleanup_old_logs() {
    local retention_days="${SSM_GLOBAL_CONFIG[SSM_LOG_RETENTION_DAYS]}"
    local logs_dir
    logs_dir=$(get_logs_dir)
    
    # 检查日志目录是否存在
    if [[ ! -d "$logs_dir" ]]; then
        return 0
    fi
    
    # 查找并删除过期日志
    find "$logs_dir" -type f -name "*.log*" -mtime +"$retention_days" -delete 2>/dev/null || true
    
    return 0
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 服务列表
# ═══════════════════════════════════════════════════════════════════════════

# 获取所有服务列表
# 返回: 服务名数组
function get_all_services() {
    local services_root
    services_root=$(get_services_root)
    
    # 检查服务根目录是否存在
    if [[ ! -d "$services_root" ]]; then
        return 0
    fi
    
    # 列出所有目录和符号链接，排除 .ssm
    local services=()
    while IFS= read -r -d '' item; do
        local basename
        basename=$(basename "$item")
        
        # 排除保留名称
        local is_reserved=false
        for reserved in "${SSM_RESERVED_NAMES[@]}"; do
            if [[ "$basename" == "$reserved" ]]; then
                is_reserved=true
                break
            fi
        done
        
        if [[ "$is_reserved" == false ]]; then
            services+=("$basename")
        fi
    done < <(find "$services_root" -maxdepth 1 \( -type d -o -type l \) ! -path "$services_root" -print0 2>/dev/null)
    
    # 输出服务列表（每行一个）
    for service in "${services[@]}"; do
        echo "$service"
    done
    
    return 0
}

# 获取运行中的服务列表
# 返回: 服务名数组
function get_running_services() {
    local all_services
    mapfile -t all_services < <(get_all_services)
    
    local running_services=()
    for service in "${all_services[@]}"; do
        if is_service_running "$service"; then
            running_services+=("$service")
        fi
    done
    
    # 输出运行中的服务列表
    for service in "${running_services[@]}"; do
        echo "$service"
    done
    
    return 0
}

# 获取已停止的服务列表
# 返回: 服务名数组
function get_stopped_services() {
    local all_services
    mapfile -t all_services < <(get_all_services)
    
    local stopped_services=()
    for service in "${all_services[@]}"; do
        if ! is_service_running "$service"; then
            stopped_services+=("$service")
        fi
    done
    
    # 输出已停止的服务列表
    for service in "${stopped_services[@]}"; do
        echo "$service"
    done
    
    return 0
}

# ═══════════════════════════════════════════════════════════════════════════
# 工具函数 - 模板生成
# ═══════════════════════════════════════════════════════════════════════════

# 生成启动脚本模板
# 参数: $1 - 输出路径
function generate_start_script_template() {
    local output_path="$1"
    
    cat > "$output_path" <<'EOF'
#!/usr/bin/env bash

# ═══════════════════════════════════════════════════════════════
# 服务启动脚本
# ═══════════════════════════════════════════════════════════════

set -euo pipefail

# 在这里编写你的服务启动代码
# 例如:
#   cd /path/to/your/app
#   exec python3 app.py

echo "服务启动脚本模板"
echo "请编辑此文件以启动你的服务"

# 保持进程运行（示例）
while true; do
    sleep 60
done
EOF
    
    # 设置可执行权限
    chmod +x "$output_path"
    
    return 0
}

# 判断字符串是否看起来像环境变量格式
# 参数: $1 - 待检查的字符串
# 返回: 0=是环境变量格式, 1=不是
function looks_like_env_string() {
    local str="$1"
    
    # 检查是否为空
    if [[ -z "$str" ]]; then
        return 1
    fi
    
    # 检查是否形如 KEY=VALUE 的环境变量格式
    # 支持: VAR=value、VAR="value"、VAR='value'、多个变量用空格分隔
    if [[ "$str" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
        return 0
    else
        return 1
    fi
}

# 验证环境变量字符串是否安全（仅支持 KEY=VALUE 的空格分隔形式）
# 参数: $1 - 环境变量字符串
# 返回: 0=合法且安全, 1=非法
function validate_env_string_safe() {
    local env_str="$1"

    if [[ -z "$env_str" ]]; then
        return 0
    fi

    local token
    for token in $env_str; do
        if [[ ! "$token" =~ ^[A-Za-z_][A-Za-z0-9_]*=[A-Za-z0-9_./:@%+,-]*$ ]]; then
            return 1
        fi
    done

    return 0
}

# 将环境变量字符串转换为安全的 export 命令片段
# 参数: $1 - 环境变量字符串
# 输出: export 命令片段
function build_safe_env_export_cmd() {
    local env_str="$1"
    local token
    local key
    local value
    local out=""

    for token in $env_str; do
        key="${token%%=*}"
        value="${token#*=}"
        out+="export ${key}=$(printf '%q' "$value"); "
    done

    echo "$out"
    return 0
}

# 获取默认命令名（优先使用无版本名 ssm）
function get_default_command_name() {
    if command -v ssm >/dev/null 2>&1; then
        echo "ssm"
    else
        echo "${CURRENT_SCRIPT_NAME}"
    fi
    return 0
}

# 获取命令注册表（用于 help tree 和路由）
function get_command_registry() {
    cat <<'EOF'
init|Initialize manager|cmd_init
create|Create a service|cmd_create
start|Start a service|cmd_start
stop|Stop a service|cmd_stop
restart|Restart a service|cmd_restart
reload|Reload config and restart|cmd_reload
status|Show service status|cmd_status
list|List services|cmd_list
logs|Show or rotate logs|cmd_logs
log-rotate|Rotate logs|cmd_log_rotate
prune|Clean stale artifacts|cmd_prune
check|Static checks|cmd_check
install|Install ssm command|cmd_install
enable|Enable auto-start for service|cmd_enable
disable|Disable auto-start for service|cmd_disable
help|Show help|cmd_help
EOF
}

# 根据命令名获取处理函数
# 参数: $1 - 命令名
function get_command_handler() {
    local command="$1"
    local line
    while IFS='|' read -r name _desc handler; do
        [[ -z "$name" ]] && continue
        if [[ "$name" == "$command" ]]; then
            echo "$handler"
            return 0
        fi
    done < <(get_command_registry)

    return 1
}

# 检测运行环境类型（system/chroot/proot）
function detect_runtime_env_type() {
    if [[ -n "${PROOT_TMP_DIR:-}" ]] || [[ -n "${PROOT_NO_SECCOMP:-}" ]] || [[ -n "${PROOT_LOADER:-}" ]]; then
        echo "proot"
        return 0
    fi

    if [[ -r /proc/1/environ ]] && tr '\0' '\n' < /proc/1/environ 2>/dev/null | grep -qi 'proot'; then
        echo "proot"
        return 0
    fi

    if command -v systemd-detect-virt >/dev/null 2>&1; then
        if systemd-detect-virt -q --chroot >/dev/null 2>&1; then
            echo "chroot"
            return 0
        fi
    fi

    if [[ -r /proc/1/root ]] && [[ "$(readlink /proc/1/root 2>/dev/null || true)" != "/" ]]; then
        echo "chroot"
        return 0
    fi

    echo "system"
    return 0
}

# 生成 enabled.sh（只包含纯启动逻辑）
function rebuild_enabled_script() {
    local enabled_file
    enabled_file=$(get_enabled_script_file)

    mkdir -p "$(get_meta_dir)"

    local cmd_name
    cmd_name=$(get_default_command_name)

    local enabled_services=()
    local all_services
    mapfile -t all_services < <(get_all_services)
    for svc in "${all_services[@]}"; do
        local enable_flag
        enable_flag=$(get_service_enable_flag "$svc")
        if [[ "$enable_flag" == "true" ]]; then
            enabled_services+=("$svc")
        fi
    done

    {
        echo "#!/usr/bin/env bash"
        echo "set -euo pipefail"
        echo ""
        if [[ ${#enabled_services[@]} -eq 0 ]]; then
            echo "# No enabled services"
        else
            local svc
            for svc in "${enabled_services[@]}"; do
                echo "${cmd_name} start ${svc}"
            done
        fi
    } > "$enabled_file"

    chmod +x "$enabled_file" 2>/dev/null || true
    return 0
}

# 读取启用钩子目标文件路径
function get_enable_hook_target() {
    local conf
    conf=$(get_enable_hook_config_file)
    if [[ ! -f "$conf" ]]; then
        echo ""
        return 1
    fi

    local line
    while IFS= read -r line; do
        if [[ "$line" =~ ^HOOK_FILE=(.*)$ ]]; then
            echo "${BASH_REMATCH[1]}"
            return 0
        fi
    done < "$conf"

    echo ""
    return 1
}

# 保存启用钩子目标文件路径
function set_enable_hook_target() {
    local hook_file="$1"
    local conf
    conf=$(get_enable_hook_config_file)
    mkdir -p "$(get_config_dir)"
    printf 'HOOK_FILE=%s\n' "$hook_file" > "$conf"
    return 0
}

# 将 enabled.sh 引入 shell 启动文件（带标记，幂等）
function ensure_enabled_hook_in_file() {
    local hook_file="$1"
    local enabled_file
    enabled_file=$(get_enabled_script_file)

    mkdir -p "$(dirname "$hook_file")"
    touch "$hook_file"

    # 已存在块则不重复写入
    if grep -qF "$SSM_ENABLED_HOOK_BEGIN" "$hook_file" 2>/dev/null; then
        return 0
    fi

    {
        echo ""
        echo "$SSM_ENABLED_HOOK_BEGIN"
        echo "if [ -f \"$enabled_file\" ]; then"
        echo "  bash \"$enabled_file\""
        echo "fi"
        echo "$SSM_ENABLED_HOOK_END"
    } >> "$hook_file"

    return 0
}

# 从 shell 启动文件删除 ssm enabled hook 块
function remove_enabled_hook_from_file() {
    local hook_file="$1"
    if [[ ! -f "$hook_file" ]]; then
        return 0
    fi

    local tmp_file
    tmp_file="${hook_file}.ssm.tmp.$$"
    awk -v begin="$SSM_ENABLED_HOOK_BEGIN" -v end="$SSM_ENABLED_HOOK_END" '
        $0==begin {skip=1; next}
        $0==end {skip=0; next}
        !skip {print}
    ' "$hook_file" > "$tmp_file"
    mv "$tmp_file" "$hook_file"

    return 0
}

# 检查服务是否已启用
function is_service_enabled() {
    local service_name="$1"
    load_service_config "$service_name"
    if [[ "${SSM_SERVICE_CONFIG[SSM_ENABLE]}" == "true" ]]; then
        return 0
    fi
    return 1
}

# 获取服务启用标记（不污染外部配置上下文）
function get_service_enable_flag() {
    local service_name="$1"
    backup_service_config
    load_service_config "$service_name"
    local enabled="${SSM_SERVICE_CONFIG[SSM_ENABLE]}"
    restore_service_config
    if [[ "$enabled" == "true" ]]; then
        echo "true"
    else
        echo "false"
    fi
    return 0
}

# 设置服务启用标记并持久化
function set_service_enable_flag() {
    local service_name="$1"
    local enabled="$2"
    local conf_file
    conf_file=$(get_service_config_file "$service_name")

    mkdir -p "$(get_service_dir "$service_name")"
    touch "$conf_file"

    local tmp_file
    tmp_file="${conf_file}.tmp.$$"
    : > "$tmp_file"
    local replaced=false
    local line

    while IFS= read -r line; do
        if [[ "$line" =~ ^[[:space:]]*SSM_ENABLE= ]]; then
            if [[ "$replaced" == false ]]; then
                echo "SSM_ENABLE=\"$enabled\"" >> "$tmp_file"
                replaced=true
            fi
            continue
        fi
        echo "$line" >> "$tmp_file"
    done < "$conf_file"

    if [[ "$replaced" == false ]]; then
        {
            [[ -s "$tmp_file" ]] && echo ""
            echo "SSM_ENABLE=\"$enabled\""
        } >> "$tmp_file"
    fi

    mv "$tmp_file" "$conf_file"
    return 0
}

# 交互选择 hook 文件（chroot/proot 时使用）
function choose_shell_hook_file_interactive() {
    local home="$SSM_TARGET_HOME"
    local options=(
        "$home/.bashrc"
        "$home/.zshrc"
        "$home/.profile"
        "$home/.bash_profile"
    )

    if is_chinese; then
        msg_notice "检测到受限环境（chroot/proot），请选择 shell 启动文件:" \
                   "Restricted environment detected (chroot/proot), choose shell startup file:"
    else
        msg_notice "Restricted environment detected (chroot/proot), choose shell startup file:" \
                   "Restricted environment detected (chroot/proot), choose shell startup file:"
    fi

    local i=1
    local opt
    for opt in "${options[@]}"; do
        echo "  ${i}) ${opt}"
        i=$((i + 1))
    done
    echo "  ${i}) custom path"

    local choice
    read -r -p "> " choice
    if [[ -z "$choice" ]] || [[ ! "$choice" =~ ^[0-9]+$ ]]; then
        return 1
    fi

    if [[ "$choice" -ge 1 ]] && [[ "$choice" -le ${#options[@]} ]]; then
        echo "${options[$((choice - 1))]}"
        return 0
    fi

    if [[ "$choice" -eq $i ]]; then
        local custom
        read -r -p "path> " custom
        if [[ -n "$custom" ]]; then
            echo "$custom"
            return 0
        fi
    fi

    return 1
}

# 安装/更新启用 hook
function ensure_enable_hook_registered() {
    local runtime
    runtime=$(detect_runtime_env_type)

    local hook_file=""
    if get_enable_hook_target >/dev/null 2>&1; then
        hook_file=$(get_enable_hook_target)
    fi

    if [[ -z "$hook_file" ]]; then
        if [[ "$runtime" == "system" ]]; then
            # 系统环境默认写入 profile，避免污染交互配置
            hook_file="${SSM_TARGET_HOME}/.profile"
        else
            if ! hook_file=$(choose_shell_hook_file_interactive); then
                msg_error "未选择有效的 shell 启动文件" "No valid shell startup file selected"
                return 1
            fi
        fi
        set_enable_hook_target "$hook_file"
    fi

    ensure_enabled_hook_in_file "$hook_file"
    return 0
}

# 如果没有任何启用服务，移除 hook
function maybe_cleanup_enable_hook() {
    local has_enabled=false
    local all_services
    mapfile -t all_services < <(get_all_services)
    local svc
    for svc in "${all_services[@]}"; do
        if [[ "$(get_service_enable_flag "$svc")" == "true" ]]; then
            has_enabled=true
            break
        fi
    done

    if [[ "$has_enabled" == "true" ]]; then
        return 0
    fi

    local hook_file
    hook_file=$(get_enable_hook_target 2>/dev/null || true)
    if [[ -n "$hook_file" ]]; then
        remove_enabled_hook_from_file "$hook_file"
    fi

    return 0
}

# 构造可安全传入 su -c 的命令行字符串
function build_shell_command_quoted() {
    local cmdline
    printf -v cmdline '%q ' "$@"
    cmdline="${cmdline% }"
    echo "$cmdline"
    return 0
}

# 检查 --depends 是否由 CLI 直接调用（拒绝脚本内调用）
function ensure_depends_cli_only() {
    # 必须是直接执行而不是被 source
    if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
        msg_error "检测到脚本内调用 --depends，已拒绝执行" "Detected scripted --depends invocation, execution denied"
        msg_notice "为避免复杂度，--depends 仅允许在 CLI 直接使用" "To avoid complexity, --depends is CLI-only"
        return 1
    fi

    # 必须连接终端（交互式）
    if [[ ! -t 0 ]] || [[ ! -t 1 ]]; then
        msg_error "检测到非交互环境调用 --depends，已拒绝执行" "Detected non-interactive --depends invocation, execution denied"
        msg_notice "为避免复杂度，--depends 仅允许在 CLI 直接使用" "To avoid complexity, --depends is CLI-only"
        return 1
    fi

    # 检查调用栈中是否出现文件来源（脚本函数链）
    local i
    for ((i = 1; i < ${#BASH_SOURCE[@]}; i++)); do
        if [[ -n "${BASH_SOURCE[$i]}" ]] && [[ "${BASH_SOURCE[$i]}" != "${BASH_SOURCE[0]}" ]]; then
            msg_error "检测到调用栈来自其他脚本，已拒绝执行 --depends" "Detected external script call stack, denied --depends"
            msg_notice "为避免复杂度，--depends 仅允许在 CLI 直接使用" "To avoid complexity, --depends is CLI-only"
            return 1
        fi
    done

    # 检查父进程参数，阻止明显的脚本包装调用
    local ppid_args
    ppid_args=$(ps -o args= -p "$PPID" 2>/dev/null || true)
    if [[ -z "${SSM_RUN_AS_ACTIVE:-}" ]] && ([[ "$ppid_args" =~ [[:space:]]-c[[:space:]] ]] || [[ "$ppid_args" =~ \.sh([[:space:]]|$) ]]); then
        msg_error "检测到父进程为脚本包装调用，已拒绝 --depends" "Detected script-wrapper parent process, denied --depends"
        msg_notice "为避免复杂度，--depends 仅允许在 CLI 直接使用" "To avoid complexity, --depends is CLI-only"
        return 1
    fi

    return 0
}

# 解析并检查 --depends 条件
# 参数: $1 - depends 服务名, $2 - depends 状态(running|stopped|dead)
function check_depends_condition() {
    local depends_service="$1"
    local depends_state="$2"

    if ! service_exists "$depends_service"; then
        msg_error "depends 服务不存在: ${depends_service}" "Depends service does not exist: ${depends_service}"
        return 1
    fi

    local actual
    actual=$(get_service_status "$depends_service")

    case "$depends_state" in
        running)
            [[ "$actual" == "$SERVICE_STATUS_RUNNING" ]]
            ;;
        stopped)
            [[ "$actual" == "$SERVICE_STATUS_STOPPED" ]]
            ;;
        dead)
            [[ "$actual" == "$SERVICE_STATUS_DEAD" ]]
            ;;
        *)
            msg_error "--depends 状态只支持: running|stopped|dead" "--depends state supports only: running|stopped|dead"
            return 1
            ;;
    esac
}

# sed 后端实现 head
function file_head_sed() {
    local file_path="$1"
    local lines="$2"
    sed -n "1,${lines}p" "$file_path"
}

# sed 后端实现 tail
function file_tail_sed() {
    local file_path="$1"
    local lines="$2"
    local total
    total=$(wc -l < "$file_path" 2>/dev/null || echo 0)
    if [[ "$total" -le "$lines" ]]; then
        sed -n '1,$p' "$file_path"
    else
        local start=$((total - lines + 1))
        sed -n "${start},\$p" "$file_path"
    fi
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - init
# ═══════════════════════════════════════════════════════════════════════════

function cmd_init() {
    local force=false
    
    # 解析参数
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=true
                shift
                ;;
            *)
                msg_error "未知选项: $1" "Unknown option: $1"
                return ${EXIT_USAGE}
                ;;
        esac
    done
    
    # 1. 检查权限
    if ! check_user_permission "$SSM_TARGET_USER"; then
        msg_error "没有权限操作用户 ${SSM_TARGET_USER}" "No permission to operate on user ${SSM_TARGET_USER}"
        return ${EXIT_PERMISSION}
    fi
    
    # 2. 检查是否已初始化
    if is_ssm_initialized; then
        if [[ "$force" != "true" ]]; then
            msg_error "SSM 已经初始化。使用 --force 强制重新初始化" "SSM is already initialized. Use --force to reinitialize"
            return ${EXIT_INIT_ERROR}
        fi
        msg_warning "强制重新初始化 SSM..." "Force reinitializing SSM..."
    fi
    
    # 3. 创建目录结构
    msg_info "创建目录结构..." "Creating directory structure..."
    
    local services_root
    services_root=$(get_services_root)
    
    # 创建服务根目录
    if ! mkdir -p "$services_root"; then
        msg_error "无法创建服务根目录: ${services_root}" "Cannot create services root directory: ${services_root}"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 创建元数据目录
    local meta_dir
    meta_dir=$(get_meta_dir)
    if ! mkdir -p "$meta_dir"; then
        msg_error "无法创建元数据目录: ${meta_dir}" "Cannot create metadata directory: ${meta_dir}"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 创建日志目录
    local logs_dir
    logs_dir=$(get_logs_dir)
    if ! mkdir -p "$logs_dir"; then
        msg_error "无法创建日志目录: ${logs_dir}" "Cannot create logs directory: ${logs_dir}"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 创建服务日志目录
    local service_logs_dir
    service_logs_dir=$(get_service_logs_dir)
    if ! mkdir -p "$service_logs_dir"; then
        msg_error "无法创建服务日志目录: ${service_logs_dir}" "Cannot create service logs directory: ${service_logs_dir}"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 创建配置目录
    local config_dir
    config_dir=$(get_config_dir)
    if ! mkdir -p "$config_dir"; then
        msg_error "无法创建配置目录: ${config_dir}" "Cannot create config directory: ${config_dir}"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 创建运行时目录
    local run_dir
    run_dir=$(get_run_dir)
    if ! mkdir -p "$run_dir"; then
        msg_error "无法创建运行时目录: ${run_dir}" "Cannot create run directory: ${run_dir}"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 创建锁目录
    local locks_dir
    locks_dir=$(get_locks_dir)
    if ! mkdir -p "$locks_dir"; then
        msg_error "无法创建锁目录: ${locks_dir}" "Cannot create locks directory: ${locks_dir}"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 创建数据目录
    local data_dir
    data_dir=$(get_data_dir)
    if ! mkdir -p "$data_dir"; then
        msg_error "无法创建数据目录: ${data_dir}" "Cannot create data directory: ${data_dir}"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 4. 生成默认配置文件
    msg_info "生成默认配置文件..." "Generating default configuration..."
    
    if ! save_global_config; then
        msg_error "无法生成全局配置文件" "Cannot generate global configuration file"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 加载配置确保一致性
    load_global_config
    
    # 5. 记录历史
    log_history "INIT" "system" "OK" "SSM initialized (force=${force})"
    log_manager "info" "SSM initialized successfully"
    
    # 显示成功消息
    msg_success "初始化完成！" "Initialization completed!"
    msg_info "服务目录: ${services_root}" "Services directory: ${services_root}"
    
    return ${EXIT_SUCCESS}
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - create
# ═══════════════════════════════════════════════════════════════════════════

function cmd_create() {
    local service_name=""
    local mode="default"  # default/copy/link
    local start_sh_in="link" # link/source (only for -cl)
    
    # 解析参数
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -cc)
                mode="copy"
                shift
                ;;
            -cl)
                mode="link"
                shift
                ;;
            --start-sh-in|--start-in)
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 $1 需要参数 (link/source)" "Option $1 requires an argument (link/source)"
                    return ${EXIT_USAGE}
                fi
                start_sh_in="$2"
                shift 2
                ;;
            *)
                if [[ -z "$service_name" ]]; then
                    service_name="$1"
                else
                    msg_error "多余参数: $1" "Extra argument: $1"
                    return ${EXIT_USAGE}
                fi
                shift
                ;;
        esac
    done
    
    # 检查服务名是否提供
    if [[ -z "$service_name" ]]; then
        msg_error "缺少服务名" "Missing service name"
        return ${EXIT_USAGE}
    fi
    
    # 1. 验证服务名
    if ! validate_service_name "$service_name"; then
        msg_error "无效的服务名: ${service_name}" "Invalid service name: ${service_name}"
        msg_info "服务名只能包含字母、数字、连字符和下划线" "Service name can only contain letters, numbers, hyphens and underscores"
        return ${EXIT_USAGE}
    fi
    
    # 检查是否已初始化
    if ! is_ssm_initialized; then
        msg_error "SSM 未初始化，请先运行: ssm init" "SSM is not initialized. Please run: ssm init"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 2. 检查服务是否存在
    if service_exists "$service_name"; then
        msg_error "服务已存在: ${service_name}" "Service already exists: ${service_name}"
        return ${EXIT_ERROR}
    fi
    
    local service_dir
    service_dir=$(get_service_dir "$service_name")

    if [[ "$start_sh_in" != "link" ]] && [[ "$start_sh_in" != "source" ]]; then
        msg_error "--start-sh-in 只支持 link 或 source" "--start-sh-in only supports link or source"
        return ${EXIT_USAGE}
    fi

    if [[ "$mode" != "link" ]] && [[ "$start_sh_in" != "link" ]]; then
        msg_error "--start-sh-in 仅在 -cl 模式下可用" "--start-sh-in is only available in -cl mode"
        return ${EXIT_USAGE}
    fi
    
    # 3. 按模式创建
    case "$mode" in
        default)
            # 创建目录
            msg_info "创建服务目录..." "Creating service directory..."
            if ! mkdir -p "$service_dir"; then
                msg_error "无法创建服务目录: ${service_dir}" "Cannot create service directory: ${service_dir}"
                return ${EXIT_ERROR}
            fi
            
            # 生成启动脚本模板
            msg_info "生成启动脚本..." "Generating start script..."
            local start_script
            start_script=$(get_service_start_script "$service_name")
            if ! generate_start_script_template "$start_script"; then
                msg_error "无法生成启动脚本" "Cannot generate start script"
                rm -rf "$service_dir"
                return ${EXIT_ERROR}
            fi
            
            # 生成服务配置文件
            msg_info "生成服务配置..." "Generating service configuration..."
            if ! generate_default_service_config "$service_dir" > "$(get_service_config_file "$service_name")"; then
                msg_error "无法生成服务配置" "Cannot generate service configuration"
                rm -rf "$service_dir"
                return ${EXIT_ERROR}
            fi
            
            log_history "CREATE" "$service_name" "OK" "mode=default"
            msg_success "服务创建成功: ${service_name}" "Service created successfully: ${service_name}"
            msg_info "服务目录: ${service_dir}" "Service directory: ${service_dir}"
            msg_notice "请编辑 ${start_script} 以定义服务启动逻辑" "Please edit ${start_script} to define service start logic"
            ;;
            
        copy)
            # 复制当前目录
            msg_info "复制当前目录到服务目录..." "Copying current directory to service directory..."
            
            local current_dir
            current_dir=$(pwd)
            
            if ! cp -r "$current_dir" "$service_dir"; then
                msg_error "无法复制目录" "Cannot copy directory"
                return ${EXIT_ERROR}
            fi
            
            # 检查并补充缺失的启动脚本
            local start_script
            start_script=$(get_service_start_script "$service_name")
            if [[ ! -f "$start_script" ]]; then
                msg_warning "未找到启动脚本，生成模板..." "Start script not found, generating template..."
                if ! generate_start_script_template "$start_script"; then
                    msg_warning "无法生成启动脚本模板" "Cannot generate start script template"
                    msg_notice "请手动创建 ${start_script}" "Please manually create ${start_script}"
                fi
            elif [[ ! -x "$start_script" ]]; then
                # 如果存在但不可执行，添加执行权限
                chmod +x "$start_script"
            fi
            
            # 检查并补充缺失的配置文件
            local config_file
            config_file=$(get_service_config_file "$service_name")
            if [[ ! -f "$config_file" ]]; then
                msg_info "生成默认服务配置..." "Generating default service configuration..."
                if ! generate_default_service_config "$service_dir" > "$config_file"; then
                    msg_warning "无法生成服务配置文件" "Cannot generate service configuration file"
                fi
            fi
            
            log_history "CREATE" "$service_name" "OK" "mode=copy from=${current_dir}"
            msg_success "服务创建成功: ${service_name}" "Service created successfully: ${service_name}"
            msg_info "服务目录: ${service_dir}" "Service directory: ${service_dir}"
            ;;
            
        link)
            # 创建符号链接
            local current_dir
            current_dir=$(pwd)
            
            msg_warning "即将创建符号链接到当前目录" "About to create symbolic link to current directory"
            msg_info "目标目录: ${current_dir}" "Target directory: ${current_dir}"
            msg_warning "注意: 删除原目录将导致服务不可用" "Warning: Deleting the original directory will make the service unavailable"
            
            # 简单确认（在非交互环境中跳过）
            if [[ -t 0 ]]; then
                echo -n "是否继续? (y/N): " >&2
                read -r confirm
                if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
                    msg_info "已取消" "Cancelled"
                    return ${EXIT_SUCCESS}
                fi
            fi
            
            msg_info "创建符号链接..." "Creating symbolic link..."
            if ! ln -s "$current_dir" "$service_dir"; then
                msg_error "无法创建符号链接" "Cannot create symbolic link"
                return ${EXIT_ERROR}
            fi

            # start.sh 优先：按策略确保启动脚本存在
            local start_script
            local source_start_script="${current_dir}/${SSM_START_SCRIPT}"
            if [[ "$start_sh_in" == "source" ]]; then
                start_script="$source_start_script"
            else
                start_script=$(get_service_start_script "$service_name")
            fi

            if [[ ! -f "$start_script" ]]; then
                msg_warning "未找到 start.sh，自动生成模板" "start.sh not found, generating template"
                if ! generate_start_script_template "$start_script"; then
                    msg_error "无法生成 start.sh: ${start_script}" "Cannot generate start.sh: ${start_script}"
                    rm -f "$service_dir"
                    return ${EXIT_ERROR}
                fi
                msg_info "已生成: ${start_script}" "Generated: ${start_script}"
            elif [[ ! -x "$start_script" ]]; then
                chmod +x "$start_script" 2>/dev/null || true
            fi

            # 生成服务配置文件（如果缺失）
            local config_file
            config_file=$(get_service_config_file "$service_name")
            if [[ ! -f "$config_file" ]]; then
                msg_info "生成默认服务配置..." "Generating default service configuration..."
                if ! generate_default_service_config "$service_dir" > "$config_file"; then
                    msg_warning "无法生成服务配置文件" "Cannot generate service configuration file"
                fi
            fi

            log_history "CREATE" "$service_name" "OK" "mode=link to=${current_dir} start_sh_in=${start_sh_in}"
            msg_success "服务创建成功 (链接): ${service_name}" "Service created successfully (link): ${service_name}"
            msg_info "链接到: ${current_dir}" "Linked to: ${current_dir}"
            msg_notice "启动脚本: ${start_script}" "Start script: ${start_script}"
            ;;
            
        *)
            msg_error "未知模式: ${mode}" "Unknown mode: ${mode}"
            return ${EXIT_ERROR}
            ;;
    esac
    
    # 4. 记录历史
    log_manager "info" "Service created: ${service_name} (mode=${mode})"
    
    return ${EXIT_SUCCESS}
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - start
# ═══════════════════════════════════════════════════════════════════════════

function cmd_start() {
    local service_name=""
    local main_env=""
    local twin_env=""
    local clear_env_flag=false
    local user_specified_env=false
    local depends_service=""
    local depends_state=""
    local force_depends=false
    
    # 解析参数
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--env)
                # 标记用户指定了 -e 参数
                user_specified_env=true
                
                # 检查是否有第一个环境变量参数
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 -e/--env 需要至少一个参数" "Option -e/--env requires at least one argument"
                    return ${EXIT_USAGE}
                fi
                
                # 第一个参数作为主服务环境变量
                main_env="$2"
                
                # 检查是否为清空模式
                if [[ -z "$main_env" ]]; then
                    clear_env_flag=true
                fi
                
                shift 2
                
                # 检查是否有第二个参数（伴生服务环境变量）
                if [[ $# -gt 0 ]] && [[ "$1" != -* ]] && looks_like_env_string "$1"; then
                    twin_env="$1"
                    shift
                fi
                ;;
            --depends)
                if [[ $# -lt 3 ]]; then
                    msg_error "选项 --depends 需要参数: <service> <running|stopped|dead>" "Option --depends requires: <service> <running|stopped|dead>"
                    return ${EXIT_USAGE}
                fi
                depends_service="$2"
                depends_state="$3"
                shift 3
                ;;
            --i-don-t-care-about-anything)
                force_depends=true
                shift
                ;;
            -*)
                msg_error "未知选项: $1" "Unknown option: $1"
                return ${EXIT_USAGE}
                ;;
            *)
                if [[ -z "$service_name" ]]; then
                    service_name="$1"
                else
                    msg_error "多余参数: $1" "Extra argument: $1"
                    return ${EXIT_USAGE}
                fi
                shift
                ;;
        esac
    done
    
    # 检查服务名是否提供
    if [[ -z "$service_name" ]]; then
        msg_error "缺少服务名" "Missing service name"
        return ${EXIT_USAGE}
    fi

    if [[ -n "$depends_service" ]]; then
        if [[ "$force_depends" != "true" ]]; then
            if ! ensure_depends_cli_only; then
                return ${EXIT_USAGE}
            fi
            if ! check_depends_condition "$depends_service" "$depends_state"; then
                msg_warning "depends 条件不满足，跳过 start: ${service_name}" "Depends condition not met, skipping start: ${service_name}"
                return ${EXIT_USAGE}
            fi
        else
            msg_warning "已启用强制模式，跳过 --depends 检查" "Force mode enabled, skipping --depends checks"
        fi
    fi
    
    # 1. 验证服务存在且有效
    if ! service_exists "$service_name"; then
        msg_error "服务不存在: ${service_name}" "Service does not exist: ${service_name}"
        return ${EXIT_NOT_FOUND}
    fi
    
    if ! is_service_valid "$service_name"; then
        msg_error "服务无效: 缺少可执行的 start.sh" "Service is invalid: missing executable start.sh"
        return ${EXIT_ERROR}
    fi
    
    # 2. 如果用户未指定 -e 参数，尝试从 .ssm.env 读取
    if [[ "$user_specified_env" == false ]]; then
        if has_env_file "$service_name"; then
            msg_info "检测到上次使用的命令行环境变量，将自动复用" \
                     "Detected previously saved environment variables, will reuse"
            
            # 读取环境变量
            if load_env_from_file "$service_name"; then
                main_env="$SSM_MAIN"
                twin_env="$SSM_TWIN"
                
                # 显示将要使用的环境变量
                if [[ -n "$main_env" ]]; then
                    if [[ -n "$twin_env" ]]; then
                        msg_info "主服务环境变量: ${main_env}" "Main service env: ${main_env}"
                        msg_info "伴生服务环境变量: ${twin_env}" "Twin service env: ${twin_env}"
                    else
                        msg_info "环境变量: ${main_env}" "Environment variables: ${main_env}"
                    fi
                fi
                
                msg_notice "使用 -e '' 清空，或使用 reload 命令忽略" \
                          "Use -e '' to clear, or use reload command to ignore"
            else
                # 读取失败，已经在 load_env_from_file 中警告过了
                main_env=""
                twin_env=""
            fi
        fi
    fi

    # 验证环境变量字符串格式与安全性
    if [[ -n "$main_env" ]] && ! validate_env_string_safe "$main_env"; then
        msg_error "主服务环境变量格式非法或包含危险字符" "Main service env format is invalid or contains unsafe characters"
        return ${EXIT_USAGE}
    fi
    if [[ -n "$twin_env" ]] && ! validate_env_string_safe "$twin_env"; then
        msg_error "伴生服务环境变量格式非法或包含危险字符" "Twin service env format is invalid or contains unsafe characters"
        return ${EXIT_USAGE}
    fi
    
    # 3. 加载配置
    load_global_config
    load_service_config "$service_name"
    
    # 设置当前服务上下文
    SSM_CURRENT_SERVICE="$service_name"
    SSM_CURRENT_SERVICE_DIR=$(get_service_dir "$service_name")
    
    # 4. 获取锁
    local lock_timeout="${SSM_GLOBAL_CONFIG[SSM_LOCK_TIMEOUT]}"
    if ! acquire_service_lock "$service_name" "$lock_timeout"; then
        msg_error "无法获取服务锁，可能有其他操作正在进行" "Cannot acquire service lock, another operation may be in progress"
        return ${EXIT_LOCK_FAILED}
    fi
    
    # 5. 双生子检测
    local twin_service
    twin_service="${SSM_SERVICE_CONFIG[SSM_TWIN]}"

    # 如果有双生子，获取其锁避免并发竞态
    if [[ -n "$twin_service" ]]; then
        if ! acquire_service_lock "$twin_service" "$lock_timeout"; then
            msg_error "无法获取伴生服务锁，可能有其他操作正在进行" "Cannot acquire twin service lock, another operation may be in progress"
            release_service_lock "$service_name"
            return ${EXIT_LOCK_FAILED}
        fi
    fi
    
    if [[ -n "$twin_service" ]]; then
        # 验证双生子配置
        if ! validate_twin_config "$service_name"; then
            msg_error "双生子配置无效: 伴生服务 ${twin_service} 也配置了双生子" \
                      "Invalid twin configuration: twin service ${twin_service} also has a twin configured"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_TWIN_ERROR}
        fi
        
        # 检查伴生服务是否存在
        if ! service_exists "$twin_service"; then
            msg_error "伴生服务不存在: ${twin_service}" "Twin service does not exist: ${twin_service}"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_NOT_FOUND}
        fi
        
        # 检查伴生服务是否有效
        if ! is_service_valid "$twin_service"; then
            msg_error "伴生服务无效: ${twin_service}" "Twin service is invalid: ${twin_service}"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_ERROR}
        fi
    else
        # 没有双生子，但提供了 twin_env
        if [[ -n "$twin_env" ]]; then
            msg_error "服务没有配置双生子，但提供了伴生服务的环境变量" \
                      "Service has no twin configured, but twin environment variables provided"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_USAGE}
        fi
    fi
    
    # 6. 检查 .pid（已运行则退出）
    if is_service_running "$service_name"; then
        local pid
        pid=$(read_service_pid "$service_name")
        msg_error "服务已在运行中 (PID: ${pid})" "Service is already running (PID: ${pid})"
        release_related_locks "$service_name" "$twin_service"
        return ${EXIT_ALREADY_RUNNING}
    fi
    
    # 清理可能存在的陈旧 PID 文件
    remove_service_pid "$service_name"
    
    # 7. 执行 pre-start 钩子
    if ! execute_hook "pre-start" "$service_name"; then
        msg_error "pre-start 钩子失败，取消启动" "pre-start hook failed, aborting start"
        log_history "START" "$service_name" "FAILED" "pre-start hook blocked"
        release_related_locks "$service_name" "$twin_service"
        return ${EXIT_HOOK_BLOCKED}
    fi
    
    # 8. 双生子启动（按 SSM_TWIN_START_ORDER）
    local start_order
    start_order=$(get_twin_start_order "$service_name")
    local twin_required
    twin_required=$(is_twin_required "$service_name" && echo "true" || echo "false")
    
    if [[ -n "$twin_service" ]]; then
        if [[ "$start_order" == "twin_first" ]]; then
            # 先启动伴生服务
            msg_info "启动伴生服务: ${twin_service}" "Starting twin service: ${twin_service}"
            
            # 加载伴生服务的配置
            load_service_config "$twin_service"
            
            if ! _start_single_service "$twin_service" "$twin_env"; then
                msg_error "伴生服务启动失败: ${twin_service}" "Failed to start twin service: ${twin_service}"
                if [[ "$twin_required" == "true" ]]; then
                    msg_error "伴生服务为必需，取消主服务启动" "Twin service is required, aborting main service start"
                    log_history "START" "$service_name" "FAILED" "twin required but failed to start"
                    release_related_locks "$service_name" "$twin_service"
                    return ${EXIT_TWIN_ERROR}
                else
                    msg_warning "伴生服务启动失败，但继续启动主服务" "Twin service failed, but continuing with main service"
                fi
            fi
            
            # 重新加载主服务配置（因为之前加载了伴生服务配置）
            load_service_config "$service_name"
            
            # 再启动主服务
            msg_info "启动主服务: ${service_name}" "Starting main service: ${service_name}"
            if ! _start_single_service "$service_name" "$main_env"; then
                msg_error "主服务启动失败" "Failed to start main service"
                # 如果主服务启动失败，停止伴生服务
                if is_service_running "$twin_service"; then
                    msg_info "回滚: 停止伴生服务" "Rollback: stopping twin service"
                    local twin_pid
                    twin_pid=$(read_service_pid "$twin_service")
                    if [[ -n "$twin_pid" ]]; then
                        local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
                        if [[ "${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}" == "true" ]]; then
                            stop_process_group "$twin_pid" "$stop_timeout" || true
                        else
                            stop_process "$twin_pid" "$stop_timeout" || true
                        fi
                        remove_service_pid "$twin_service"
                    fi
                fi
                log_history "START" "$service_name" "FAILED" "main service failed to start"
                release_related_locks "$service_name" "$twin_service"
                return ${EXIT_ERROR}
            fi
        else
            # main_first: 先启动主服务
            msg_info "启动主服务: ${service_name}" "Starting main service: ${service_name}"
            if ! _start_single_service "$service_name" "$main_env"; then
                msg_error "主服务启动失败" "Failed to start main service"
                log_history "START" "$service_name" "FAILED" "main service failed to start"
                release_related_locks "$service_name" "$twin_service"
                return ${EXIT_ERROR}
            fi
            
            # 再启动伴生服务
            msg_info "启动伴生服务: ${twin_service}" "Starting twin service: ${twin_service}"
            
            # 加载伴生服务的配置
            load_service_config "$twin_service"
            
            if ! _start_single_service "$twin_service" "$twin_env"; then
                msg_error "伴生服务启动失败: ${twin_service}" "Failed to start twin service: ${twin_service}"
                if [[ "$twin_required" == "true" ]]; then
                    msg_error "伴生服务为必需，回滚主服务" "Twin service is required, rolling back main service"
                    local main_pid
                    main_pid=$(read_service_pid "$service_name")
                    if [[ -n "$main_pid" ]]; then
                        local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
                        if [[ "${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}" == "true" ]]; then
                            stop_process_group "$main_pid" "$stop_timeout" || true
                        else
                            stop_process "$main_pid" "$stop_timeout" || true
                        fi
                        remove_service_pid "$service_name"
                    fi
                    log_history "START" "$service_name" "FAILED" "twin required but failed to start"
                    release_related_locks "$service_name" "$twin_service"
                    return ${EXIT_TWIN_ERROR}
                else
                    msg_warning "伴生服务启动失败，但主服务已启动" "Twin service failed, but main service is running"
                fi
            fi
            
            # 重新加载主服务配置（因为加载了伴生服务配置）
            load_service_config "$service_name"
        fi
    else
        # 没有双生子，直接启动主服务
        if ! _start_single_service "$service_name" "$main_env"; then
            msg_error "服务启动失败" "Failed to start service"
            log_history "START" "$service_name" "FAILED" "service failed to start"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_ERROR}
        fi
    fi
    
    # 9. 执行 post-start 钩子
    if ! execute_hook "post-start" "$service_name"; then
        msg_warning "post-start 钩子失败" "post-start hook failed"
        # post-start 失败不影响服务运行
    fi
    
    # 10. 处理 .ssm.env 文件
    if [[ "$clear_env_flag" == true ]]; then
        # 清空模式：删除 .ssm.env
        if has_env_file "$service_name"; then
            remove_env_file "$service_name"
            msg_info "已清空命令行环境变量" "Cleared command-line environment variables"
            msg_info "服务将使用配置文件中的环境变量（如果有）" \
                     "Service will use environment variables from config file (if any)"
        fi
    elif [[ "$user_specified_env" == true ]]; then
        # 用户指定了 -e 参数（非清空模式）：保存到 .ssm.env
        if [[ -n "$main_env" ]] || [[ -n "$twin_env" ]]; then
            save_env_to_file "$service_name" "$main_env" "$twin_env"
        fi
    fi
    # 如果是自动复用模式，不修改 .ssm.env 文件
    
    # 11. 记录历史
    local pid
    pid=$(read_service_pid "$service_name")
    local details="pid=${pid}"
    if [[ -n "$main_env" ]] || [[ -n "$twin_env" ]]; then
        details="${details} with_env=true"
    fi
    log_history "START" "$service_name" "OK" "$details"
    log_manager "info" "Service started: ${service_name} (PID: ${pid})"
    
    # 显示成功消息
    msg_success "服务 '${service_name}' 启动成功 (PID: ${pid})" \
                "Service '${service_name}' started successfully (PID: ${pid})"
    
    if [[ -n "$twin_service" ]]; then
        local twin_pid
        twin_pid=$(read_service_pid "$twin_service" 2>/dev/null || echo "N/A")
        msg_info "伴生服务 '${twin_service}' (PID: ${twin_pid})" \
                 "Twin service '${twin_service}' (PID: ${twin_pid})"
    fi
    
    # 12. 释放锁
    release_related_locks "$service_name" "$twin_service"
    
    return ${EXIT_SUCCESS}
}

# 内部函数：启动单个服务（不包含双生子逻辑）
# 参数: $1 - 服务名, $2 - 命令行环境变量字符串（可选）
# 注意: 此函数会在内部备份/恢复 SSM_SERVICE_CONFIG，不会污染调用方的配置上下文
function _start_single_service() {
    local service_name="$1"
    local cmd_env="${2:-}"
    local service_dir
    service_dir=$(get_service_dir "$service_name")
    local start_script
    start_script=$(get_service_start_script "$service_name")
    local pid_file
    pid_file=$(get_service_pid_file "$service_name")
    
    # 备份调用方的服务配置，防止内部 load_service_config 污染
    backup_service_config
    
    # 加载本服务的配置
    load_service_config "$service_name"
    
    # 设置工作目录
    local working_dir="${SSM_SERVICE_CONFIG[SSM_WORKING_DIR]}"
    if [[ -z "$working_dir" ]]; then
        working_dir="$service_dir"
    fi
    
    # 检查工作目录是否存在
    if [[ ! -d "$working_dir" ]]; then
        msg_error "工作目录不存在: ${working_dir}" "Working directory does not exist: ${working_dir}"
        restore_service_config
        return 1
    fi
    
    # 设置 umask
    local umask_value="${SSM_GLOBAL_CONFIG[SSM_DEFAULT_UMASK]}"
    umask "$umask_value"
    
    # 准备日志文件
    local capture_output="${SSM_GLOBAL_CONFIG[SSM_CAPTURE_OUTPUT]}"
    local output_mode="${SSM_GLOBAL_CONFIG[SSM_OUTPUT_MODE]}"
    
    local out_log
    out_log=$(get_service_out_log "$service_name")
    local err_log
    err_log=$(get_service_err_log "$service_name")
    
    # 确保日志目录存在
    mkdir -p "$(dirname "$out_log")" || {
        msg_error "无法创建日志目录" "Cannot create log directory"
        restore_service_config
        return 1
    }
    
    # 准备环境变量文件（来自 .ssm.conf中的 SSM_ENV_FILE 配置）
    local env_file="${SSM_SERVICE_CONFIG[SSM_ENV_FILE]}"
    if [[ -n "$env_file" ]]; then
        # 如果不是绝对路径，相对于服务目录
        if [[ "$env_file" != /* ]]; then
            env_file="${service_dir}/${env_file}"
        fi
        
        # 验证环境变量文件存在且可读
        if [[ ! -f "$env_file" ]]; then
            msg_warning "环境变量文件不存在: ${env_file}" "Environment file does not exist: ${env_file}"
            env_file=""
        elif [[ ! -r "$env_file" ]]; then
            msg_warning "环境变量文件不可读: ${env_file}" "Environment file is not readable: ${env_file}"
            env_file=""
        fi
    fi
    
    # 构建启动命令
    local start_cmd="cd '${working_dir}' || exit 1; "
    # 添加配置文件中的环境变量加载
    if [[ -n "$env_file" ]]; then
        start_cmd+="set -a; source '${env_file}'; set +a; "
    fi
    
    # 添加命令行环境变量（优先级高于配置文件，会覆盖同名变量）
    if [[ -n "$cmd_env" ]]; then
        start_cmd+="$(build_safe_env_export_cmd "$cmd_env")"
    fi
    
    # 添加启动脚本
    start_cmd+="exec '${start_script}'"
    
    # 启动进程
    local pid
    if [[ "$capture_output" == "true" ]]; then
        if [[ "$output_mode" == "combined" ]]; then
            setsid bash -c "$start_cmd" >> "$out_log" 2>&1 &
        else
            setsid bash -c "$start_cmd" >> "$out_log" 2>> "$err_log" &
        fi
    else
        setsid bash -c "$start_cmd" &
    fi
    
    # 获取子shell 的 PID
    local shell_pid=$!
    
    # 等待一小段时间让setsid 创建新会话
    sleep 0.2
    
    # 获取实际的会话 leader PID（即 setsid 创建的进程）
    # 通过 pgid 查找，因为 setsid 会创建新的进程组
    local actual_pid
    actual_pid=$(ps -o pid= --ppid "$shell_pid" 2>/dev/null | head -n1 | tr -d ' ')
    
    # 如果找不到子进程，可能 shell 已经 exec，使用原PID
    if [[ -z "$actual_pid" ]]; then
        # 检查 shell_pid 是否还存在
        if is_process_alive "$shell_pid"; then
            actual_pid="$shell_pid"
        else
            msg_error "无法获取进程 PID，进程可能启动失败" "Cannot get process PID, process may have failed to start"
            restore_service_config
            return 1
        fi
    fi
    
    pid="$actual_pid"
    
    # 检查是否成功获取 PID
    if [[ -z "$pid" ]] || [[ ! "$pid" =~ ^[0-9]+$ ]]; then
        msg_error "无法获取进程 PID" "Cannot get process PID"
        restore_service_config
        return 1
    fi
    
    # 写入 .pid
    write_service_pid "$service_name" "$pid"
    
    # 等待 grace period
    local grace_period="${SSM_GLOBAL_CONFIG[SSM_START_GRACE_PERIOD]}"
    sleep "$grace_period"
    
    # 验证进程存活
    if ! is_process_alive "$pid"; then
        # 防呆：主进程已退出，尝试查找它的子进程（start.sh 中可能用了 & 而非 exec）
        local child_pid
        child_pid=$(pgrep -s "$pid" 2>/dev/null | head -n1)
        
        # 也尝试通过进程组查找
        if [[ -z "$child_pid" ]]; then
            local pgid
            pgid=$(ps -o pgid= -p "$pid" 2>/dev/null | tr -d ' ')
            if [[ -n "$pgid" ]]; then
                child_pid=$(pgrep -g "$pgid" 2>/dev/null | head -n1)
            fi
        fi
        
        if [[ -n "$child_pid" ]] && is_process_alive "$child_pid"; then
            msg_warning "主进程已退出，检测到子进程 (PID: ${child_pid})" "Main process exited, detected child process (PID: ${child_pid})"
            msg_warning "建议在 start.sh 中使用 exec 替代后台运行 (&)" \
                        "Recommend using exec in start.sh instead of background (&)"
            # 更新 PID 为子进程
            pid="$child_pid"
            write_service_pid "$service_name" "$pid"
        else
            msg_error "服务启动后立即退出" "Service exited immediately after start"
            remove_service_pid "$service_name"
            
            # 输出最后几行日志帮助调试
            if [[ -f "$out_log" ]]; then
                msg_info "最后的日志输出:" "Last log output:"
                tail -n 5 "$out_log" >&2
            fi
            
            restore_service_config
            return 1
        fi
    fi
    
    # 启动成功，恢复调用方的服务配置
    restore_service_config
    
    return 0
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - stop
# ═══════════════════════════════════════════════════════════════════════════

function cmd_stop() {
    local service_name=""
    local depends_service=""
    local depends_state=""
    local force_depends=false

    # 解析参数
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --depends)
                if [[ $# -lt 3 ]]; then
                    msg_error "选项 --depends 需要参数: <service> <running|stopped|dead>" "Option --depends requires: <service> <running|stopped|dead>"
                    return ${EXIT_USAGE}
                fi
                depends_service="$2"
                depends_state="$3"
                shift 3
                ;;
            --i-don-t-care-about-anything)
                force_depends=true
                shift
                ;;
            -*)
                msg_error "未知选项: $1" "Unknown option: $1"
                return ${EXIT_USAGE}
                ;;
            *)
                if [[ -z "$service_name" ]]; then
                    service_name="$1"
                else
                    msg_error "多余参数: $1" "Extra argument: $1"
                    return ${EXIT_USAGE}
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$service_name" ]]; then
        msg_error "缺少服务名" "Missing service name"
        return ${EXIT_USAGE}
    fi

    if [[ -n "$depends_service" ]]; then
        if [[ "$force_depends" != "true" ]]; then
            if ! ensure_depends_cli_only; then
                return ${EXIT_USAGE}
            fi
            if ! check_depends_condition "$depends_service" "$depends_state"; then
                msg_warning "depends 条件不满足，跳过 stop: ${service_name}" "Depends condition not met, skipping stop: ${service_name}"
                return ${EXIT_USAGE}
            fi
        else
            msg_warning "已启用强制模式，跳过 --depends 检查" "Force mode enabled, skipping --depends checks"
        fi
    fi
    
    # 1. 验证服务存在
    if ! service_exists "$service_name"; then
        msg_error "服务不存在: ${service_name}" "Service does not exist: ${service_name}"
        return ${EXIT_NOT_FOUND}
    fi
    
    # 2. 加载配置
    load_global_config
    load_service_config "$service_name"
    
    # 3. 获取锁
    local lock_timeout="${SSM_GLOBAL_CONFIG[SSM_LOCK_TIMEOUT]}"
    if ! acquire_service_lock "$service_name" "$lock_timeout"; then
        msg_error "无法获取服务锁，可能有其他操作正在进行" "Cannot acquire service lock, another operation may be in progress"
        return ${EXIT_LOCK_FAILED}
    fi
    
    # 4. 读取 .pid（在锁保护下进行，避免竞态条件）
    local pid
    pid=$(read_service_pid "$service_name")
    
    if [[ -z "$pid" ]]; then
        msg_error "服务未在运行（未找到 PID 文件）" "Service is not running (PID file not found)"
        release_service_lock "$service_name"
        return ${EXIT_NOT_RUNNING}
    fi
    
    # 验证 PID 格式
    if [[ ! "$pid" =~ ^[0-9]+$ ]]; then
        msg_warning "PID 文件内容无效: ${pid}" "Invalid PID file content: ${pid}"
        remove_service_pid "$service_name"
        release_service_lock "$service_name"
        return ${EXIT_NOT_RUNNING}
    fi
    
    # 检查进程是否真的存在且与 PID 文件匹配（在锁内再次检查）
    if ! is_same_service_process "$service_name" "$pid"; then
        msg_warning "PID 文件存在但进程已不存在，清理 PID 文件" "PID file exists but process is dead, cleaning up"
        remove_service_pid "$service_name"
        log_history "STOP" "$service_name" "CLEANED" "stale pid=${pid}"
        release_service_lock "$service_name"
        return ${EXIT_NOT_RUNNING}
    fi
    
    # 5. 执行 pre-stop 钩子
    if ! execute_hook "pre-stop" "$service_name"; then
        msg_warning "pre-stop 钩子失败" "pre-stop hook failed"
        # pre-stop 失败不阻止停止操作
    fi
    
    # 6. 发送 SIGTERM
    msg_info "停止服务 (PID: ${pid})..." "Stopping service (PID: ${pid})..."
    
    local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
    local kill_process_group="${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}"
    
    # 7. 等待超时，必要时 SIGKILL
    local stop_success=false
    if [[ "$kill_process_group" == "true" ]]; then
        if stop_process_group "$pid" "$stop_timeout"; then
            stop_success=true
        fi
    else
        if stop_process "$pid" "$stop_timeout"; then
            stop_success=true
        fi
    fi
    
    if [[ "$stop_success" != "true" ]]; then
        msg_error "无法停止服务进程" "Failed to stop service process"
        release_service_lock "$service_name"
        return ${EXIT_ERROR}
    fi
    
    # 8. 删除 .pid
    remove_service_pid "$service_name"
    
    # 9. 双生子停止（若 SSM_TWIN_STOP_TOGETHER=true）
    if should_stop_twin_together "$service_name"; then
        local twin_service="${SSM_SERVICE_CONFIG[SSM_TWIN]}"
        if [[ -n "$twin_service" ]] && is_service_running "$twin_service"; then
            msg_info "停止伴生服务: ${twin_service}" "Stopping twin service: ${twin_service}"
            
            local twin_pid
            twin_pid=$(read_service_pid "$twin_service")
            
            if [[ -n "$twin_pid" ]] && is_same_service_process "$twin_service" "$twin_pid"; then
                if [[ "$kill_process_group" == "true" ]]; then
                    stop_process_group "$twin_pid" "$stop_timeout" || true
                else
                    stop_process "$twin_pid" "$stop_timeout" || true
                fi
                remove_service_pid "$twin_service"
                log_history "STOP" "$twin_service" "OK" "(twin stop with ${service_name})"
            fi
        fi
    fi
    
    # 10. 执行 post-stop 钩子
    if ! execute_hook "post-stop" "$service_name"; then
        msg_warning "post-stop 钩子失败" "post-stop hook failed"
        # post-stop 失败不影响停止结果
    fi
    
    # 11. 记录历史
    log_history "STOP" "$service_name" "OK" "pid=${pid} signal=TERM"
    log_manager "info" "Service stopped: ${service_name}"
    
    # 显示成功消息
    msg_success "服务 '${service_name}' 已停止" "Service '${service_name}' stopped"
    
    # 12. 释放锁
    release_service_lock "$service_name"
    
    return ${EXIT_SUCCESS}
}


# 内部函数：停止单个服务（不包含双生子逻辑）
# 参数: $1 - 服务名
function _stop_single_service() {
    local service_name="$1"
    
    # 读取 PID
    local pid
    pid=$(read_service_pid "$service_name")
    
    if [[ -z "$pid" ]]; then
        return 0
    fi
    
    # 检查进程是否存在且与 PID 文件匹配
    if ! is_same_service_process "$service_name" "$pid"; then
        remove_service_pid "$service_name"
        return 0
    fi
    
    # 加载配置获取停止超时
    load_service_config "$service_name"
    local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
    local kill_process_group="${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}"
    
    # 停止进程
    if [[ "$kill_process_group" == "true" ]]; then
        stop_process_group "$pid" "$stop_timeout"
    else
        stop_process "$pid" "$stop_timeout"
    fi
    
    local result=$?
    
    # 删除 PID 文件
    remove_service_pid "$service_name"
    
    return $result
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - reload
# ═══════════════════════════════════════════════════════════════════════════

function cmd_reload() {
    local service_name=""
    local depends_service=""
    local depends_state=""
    local force_depends=false
    # 解析参数
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--env)
                msg_error "reload命令不接受 -e/--env 参数" \
                "reload command does not accept -e/--env option"
                msg_notice "reload 用于清除命令行环境变量并重新加载配置" \
                           "reload is used to clear command-line env vars and reload config"
                msg_notice "如需修改环境变量，请使用: restart --env '...'" \
                           "To modify environment variables, use: restart --env '...'"
                return ${EXIT_USAGE}
                ;;
            --depends)
                if [[ $# -lt 3 ]]; then
                    msg_error "选项 --depends 需要参数: <service> <running|stopped|dead>" "Option --depends requires: <service> <running|stopped|dead>"
                    return ${EXIT_USAGE}
                fi
                depends_service="$2"
                depends_state="$3"
                shift 3
                ;;
            --i-don-t-care-about-anything)
                force_depends=true
                shift
                ;;
            -*)
                msg_error "未知选项: $1" "Unknown option: $1"
                return ${EXIT_USAGE}
                ;;
            *)
                if [[ -z "$service_name" ]]; then
                    service_name="$1"
                else
                    msg_error "多余参数: $1" "Extra argument: $1"
                    return ${EXIT_USAGE}
                fi
                shift
                ;;
        esac
    done
    
    # 检查服务名是否提供
    if [[ -z "$service_name" ]]; then
        msg_error "缺少服务名" "Missing service name"
        return ${EXIT_USAGE}
    fi

    if [[ -n "$depends_service" ]]; then
        if [[ "$force_depends" != "true" ]]; then
            if ! ensure_depends_cli_only; then
                return ${EXIT_USAGE}
            fi
            if ! check_depends_condition "$depends_service" "$depends_state"; then
                msg_warning "depends 条件不满足，跳过 reload: ${service_name}" "Depends condition not met, skipping reload: ${service_name}"
                return ${EXIT_USAGE}
            fi
        else
            msg_warning "已启用强制模式，跳过 --depends 检查" "Force mode enabled, skipping --depends checks"
        fi
    fi
    
    # 1. 验证服务存在且有效
    if ! service_exists "$service_name"; then
        msg_error "服务不存在: ${service_name}" "Service does not exist: ${service_name}"
        return ${EXIT_NOT_FOUND}
    fi
    
    if ! is_service_valid "$service_name"; then
        msg_error "服务无效: 缺少可执行的 start.sh" "Service is invalid: missing executable start.sh"
        return ${EXIT_ERROR}
    fi
    
    # 2. 加载配置
    load_global_config
    load_service_config "$service_name"
    
    # 设置当前服务上下文
    SSM_CURRENT_SERVICE="$service_name"
    SSM_CURRENT_SERVICE_DIR=$(get_service_dir "$service_name")
    
    # 3. 获取锁
    local lock_timeout="${SSM_GLOBAL_CONFIG[SSM_LOCK_TIMEOUT]}"
    if ! acquire_service_lock "$service_name" "$lock_timeout"; then
        msg_error "无法获取服务锁，可能有其他操作正在进行" "Cannot acquire service lock, another operation may be in progress"
        return ${EXIT_LOCK_FAILED}
    fi
    
    # 4. 提示用户 reload 的作用
    msg_info "reload 命令将清除命令行环境变量" "reload command will clear command-line environment variables"
    # 5. 删除 .ssm.env 文件（如果存在）
    if has_env_file "$service_name"; then
        remove_env_file "$service_name"
        msg_info "已清除命令行环境变量" "Cleared command-line environment variables"
    fi
    
    # 6. 检测双生子
    local twin_service
    twin_service="${SSM_SERVICE_CONFIG[SSM_TWIN]}"

    # 如果有双生子，获取其锁避免并发竞态
    if [[ -n "$twin_service" ]]; then
        if ! acquire_service_lock "$twin_service" "$lock_timeout"; then
            msg_error "无法获取伴生服务锁，可能有其他操作正在进行" "Cannot acquire twin service lock, another operation may be in progress"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_LOCK_FAILED}
        fi
    fi
    
    if [[ -n "$twin_service" ]]; then
        # 验证双生子配置
        if ! validate_twin_config "$service_name"; then
            msg_error "双生子配置无效: 伴生服务 ${twin_service} 也配置了双生子" \
                      "Invalid twin configuration: twin service ${twin_service} also has a twin configured"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_TWIN_ERROR}
        fi
        
        # 检查伴生服务
        if ! service_exists "$twin_service"; then
            msg_error "伴生服务不存在: ${twin_service}" "Twin service does not exist: ${twin_service}"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_NOT_FOUND}
        fi
        
        if ! is_service_valid "$twin_service"; then
            msg_error "伴生服务无效: ${twin_service}" "Twin service is invalid: ${twin_service}"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_ERROR}
        fi
    fi
    
    # 7. 执行 pre-restart钩子
    if ! execute_hook "pre-restart" "$service_name"; then
        msg_error "pre-restart 钩子失败，取消重新加载" "pre-restart hook failed, aborting reload"
        log_history "RELOAD" "$service_name" "FAILED" "pre-restart hook blocked"
        release_related_locks "$service_name" "$twin_service"
        return ${EXIT_HOOK_BLOCKED}
    fi
    
    # 8. 停止主服务（如果正在运行）
    local was_running=false
    if is_service_running "$service_name"; then
        was_running=true
        msg_info "停止服务..." "Stopping service..."
        
        local pid
        pid=$(read_service_pid "$service_name")
        if [[ -n "$pid" ]]; then
            # 执行 pre-stop 钩子
            if ! execute_hook "pre-stop" "$service_name"; then
                msg_warning "pre-stop 钩子失败" "pre-stop hook failed"
            fi
            
            # 停止进程
            local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
            local kill_process_group="${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}"
            
            if [[ "$kill_process_group" == "true" ]]; then
                if ! stop_process_group "$pid" "$stop_timeout"; then
                    msg_error "停止服务失败" "Failed to stop service"
                    log_history "RELOAD" "$service_name" "FAILED" "stop failed"
                    release_related_locks "$service_name" "$twin_service"
                    return ${EXIT_ERROR}
                fi
            else
                if ! stop_process "$pid" "$stop_timeout"; then
                    msg_error "停止服务失败" "Failed to stop service"
                    log_history "RELOAD" "$service_name" "FAILED" "stop failed"
                    release_related_locks "$service_name" "$twin_service"
                    return ${EXIT_ERROR}
                fi
            fi
            
            # 删除 PID 文件
            remove_service_pid "$service_name"
            
            # 执行 post-stop 钩子
            if ! execute_hook "post-stop" "$service_name"; then
                msg_warning "post-stop 钩子失败" "post-stop hook failed"
            fi
        fi
    else
        msg_info "服务未运行，直接启动" "Service is not running, starting directly"
    fi
    
    # 停止伴生服务（如果正在运行）
    if [[ -n "$twin_service" ]] && is_service_running "$twin_service"; then
        msg_info "停止伴生服务: ${twin_service}" "Stopping twin service: ${twin_service}"
        
        local twin_pid
        twin_pid=$(read_service_pid "$twin_service")
        
        if [[ -n "$twin_pid" ]]; then
            local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
            local kill_process_group="${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}"
            
            if [[ "$kill_process_group" == "true" ]]; then
                if ! stop_process_group "$twin_pid" "$stop_timeout"; then
                    msg_warning "停止伴生服务失败: ${twin_service}" "Failed to stop twin service: ${twin_service}"
                fi
            else
                if ! stop_process "$twin_pid" "$stop_timeout"; then
                    msg_warning "停止伴生服务失败: ${twin_service}" "Failed to stop twin service: ${twin_service}"
                fi
            fi
            
            remove_service_pid "$twin_service"
        fi
    fi
    
    # 9. 重新加载配置
    msg_info "重新加载配置文件..." "Reloading configuration..."
    load_global_config
    load_service_config "$service_name"
    
    msg_info "服务将使用配置文件中的环境变量" \
             "Service will use environment variables from config file"
    
    # 10. 执行 pre-start 钩子
    if ! execute_hook "pre-start" "$service_name"; then
        msg_error "pre-start 钩子失败，取消启动" "pre-start hook failed, aborting start"
        log_history "RELOAD" "$service_name" "FAILED" "pre-start hook blocked"
        release_related_locks "$service_name" "$twin_service"
        return ${EXIT_HOOK_BLOCKED}
    fi
    
    # 11. 启动服务（不传递环境变量参数）
    msg_info "启动服务..." "Starting service..."
    
    # 双生子启动逻辑
    local start_order
    start_order=$(get_twin_start_order "$service_name")
    local twin_required
    twin_required=$(is_twin_required "$service_name" && echo "true" || echo "false")
    
    if [[ -n "$twin_service" ]]; then
        if [[ "$start_order" == "twin_first" ]]; then
            # 先启动伴生服务
            msg_info "启动伴生服务: ${twin_service}" "Starting twin service: ${twin_service}"
            
            # 加载伴生服务配置
            load_service_config "$twin_service"
            
            # 不传递环境变量参数
            if ! _start_single_service "$twin_service" ""; then
                msg_error "伴生服务启动失败: ${twin_service}" "Failed to start twin service: ${twin_service}"
                if [[ "$twin_required" == "true" ]]; then
                    msg_error "伴生服务为必需，取消主服务启动" "Twin service is required, aborting main service start"
                    log_history "RELOAD" "$service_name" "FAILED" "twin required but failed to start"
                    release_related_locks "$service_name" "$twin_service"
                    return ${EXIT_TWIN_ERROR}
                fi
            fi
            
            # 重新加载主服务配置
            load_service_config "$service_name"
            
            # 再启动主服务
            msg_info "启动主服务: ${service_name}" "Starting main service: ${service_name}"
            if ! _start_single_service "$service_name" ""; then
                msg_error "主服务启动失败" "Failed to start main service"
                # 回滚：停止伴生服务
                if is_service_running "$twin_service"; then
                    msg_info "回滚: 停止伴生服务" "Rollback: stopping twin service"
                    local twin_pid
                    twin_pid=$(read_service_pid "$twin_service")
                    if [[ -n "$twin_pid" ]]; then
                        local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
                        if [[ "${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}" == "true" ]]; then
                            stop_process_group "$twin_pid" "$stop_timeout" || true
                        else
                            stop_process "$twin_pid" "$stop_timeout" || true
                        fi
                        remove_service_pid "$twin_service"
                    fi
                fi
                
                log_history "RELOAD" "$service_name" "FAILED" "main service failed to start"
                release_related_locks "$service_name" "$twin_service"
                return ${EXIT_ERROR}
            fi
        else
            # main_first: 先启动主服务
            msg_info "启动主服务: ${service_name}" "Starting main service: ${service_name}"
            if ! _start_single_service "$service_name" ""; then
                msg_error "主服务启动失败" "Failed to start main service"
                log_history "RELOAD" "$service_name" "FAILED" "main service failed to start"
                release_related_locks "$service_name" "$twin_service"
                return ${EXIT_ERROR}
            fi
            
            # 再启动伴生服务
            msg_info "启动伴生服务: ${twin_service}" "Starting twin service: ${twin_service}"
            
            # 加载伴生服务配置
            load_service_config "$twin_service"
            
            if ! _start_single_service "$twin_service" ""; then
                msg_error "伴生服务启动失败: ${twin_service}" "Failed to start twin service: ${twin_service}"
                if [[ "$twin_required" == "true" ]]; then
                    msg_error "伴生服务为必需，回滚主服务" "Twin service is required, rolling back main service"
                    
                    # 回滚：停止主服务
                    local main_pid
                    main_pid=$(read_service_pid "$service_name")
                    if [[ -n "$main_pid" ]]; then
                        local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
                        if [[ "${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}" == "true" ]]; then
                            stop_process_group "$main_pid" "$stop_timeout" || true
                        else
                            stop_process "$main_pid" "$stop_timeout" || true
                        fi
                        remove_service_pid "$service_name"
                    fi
                
                    log_history "RELOAD" "$service_name" "FAILED" "twin required but failed to start"
                    release_related_locks "$service_name" "$twin_service"
                    return ${EXIT_TWIN_ERROR}
                fi
            fi
            
            # 重新加载主服务配置
            load_service_config "$service_name"
        fi
    else
        # 没有双生子，直接启动主服务
        if ! _start_single_service "$service_name" ""; then
            msg_error "服务启动失败" "Failed to start service"
            log_history "RELOAD" "$service_name" "FAILED" "service failed to start"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_ERROR}
        fi
    fi
    
    # 12. 执行 post-start 钩子
    if ! execute_hook "post-start" "$service_name"; then
        msg_warning "post-start 钩子失败" "post-start hook failed"
    fi
    
    # 13. 执行 post-restart 钩子
    if ! execute_hook "post-restart" "$service_name"; then
        msg_warning "post-restart 钩子失败" "post-restart hook failed"
    fi
    
    # 14. 记录历史
    local pid
    pid=$(read_service_pid "$service_name")
    log_history "RELOAD" "$service_name" "OK" "pid=${pid}"
    log_manager "info" "Service reloaded: ${service_name} (PID: ${pid})"
    
    # 显示成功消息
    msg_success "服务 '${service_name}' 已重新加载并启动 (PID: ${pid})" \
                "Service '${service_name}' reloaded and started (PID: ${pid})"
    
    if [[ -n "$twin_service" ]]; then
        local twin_pid
        twin_pid=$(read_service_pid "$twin_service" 2>/dev/null || echo "N/A")
        msg_info "伴生服务 '${twin_service}' (PID: ${twin_pid})" \
                 "Twin service '${twin_service}' (PID: ${twin_pid})"
    fi
    
    # 15. 释放锁
    release_related_locks "$service_name" "$twin_service"
    
    return ${EXIT_SUCCESS}
}

#═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - restart
# ═══════════════════════════════════════════════════════════════════════════

function cmd_restart() {
    local service_name=""
    local main_env=""
    local twin_env=""
    local clear_env_flag=false
    local user_specified_env=false
    local depends_service=""
    local depends_state=""
    local force_depends=false
    
    # 解析参数
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--env)
                # 标记用户指定了-e 参数
                user_specified_env=true
                
                # 检查是否有第一个环境变量参数
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 -e/--env 需要至少一个参数" "Option -e/--env requires at least one argument"
                    return ${EXIT_USAGE}
                fi
                
                # 第一个参数作为主服务环境变量
                main_env="$2"
                
                # 检查是否为清空模式
                if [[ -z "$main_env" ]]; then
                    clear_env_flag=true
                fi
                
                shift 2
                
                # 检查是否有第二个参数（伴生服务环境变量）
                if [[ $# -gt 0 ]] && [[ "$1" != -* ]] && looks_like_env_string "$1"; then
                    twin_env="$1"
                    shift
                fi
                ;;
            --depends)
                if [[ $# -lt 3 ]]; then
                    msg_error "选项 --depends 需要参数: <service> <running|stopped|dead>" "Option --depends requires: <service> <running|stopped|dead>"
                    return ${EXIT_USAGE}
                fi
                depends_service="$2"
                depends_state="$3"
                shift 3
                ;;
            --i-don-t-care-about-anything)
                force_depends=true
                shift
                ;;
            -*)
                msg_error "未知选项: $1" "Unknown option: $1"
                return ${EXIT_USAGE}
                ;;
            *)
                if [[ -z "$service_name" ]]; then
                    service_name="$1"
                else
                    msg_error "多余参数: $1" "Extra argument: $1"
                    return ${EXIT_USAGE}
                fi
                shift
                ;;
        esac
    done
    
    # 检查服务名是否提供
    if [[ -z "$service_name" ]]; then
        msg_error "缺少服务名" "Missing service name"
        return ${EXIT_USAGE}
    fi

    if [[ -n "$depends_service" ]]; then
        if [[ "$force_depends" != "true" ]]; then
            if ! ensure_depends_cli_only; then
                return ${EXIT_USAGE}
            fi
            if ! check_depends_condition "$depends_service" "$depends_state"; then
                msg_warning "depends 条件不满足，跳过 restart: ${service_name}" "Depends condition not met, skipping restart: ${service_name}"
                return ${EXIT_USAGE}
            fi
        else
            msg_warning "已启用强制模式，跳过 --depends 检查" "Force mode enabled, skipping --depends checks"
        fi
    fi
    
    # 1. 验证服务存在且有效
    if ! service_exists "$service_name"; then
        msg_error "服务不存在: ${service_name}" "Service does not exist: ${service_name}"
        return ${EXIT_NOT_FOUND}
    fi
    
    if ! is_service_valid "$service_name"; then
        msg_error "服务无效: 缺少可执行的start.sh" "Service is invalid: missing executable start.sh"
        return ${EXIT_ERROR}
    fi
    
    # 2. 如果用户未指定 -e 参数，尝试从 .ssm.env 读取
    if [[ "$user_specified_env" == false ]]; then
        if has_env_file "$service_name"; then
            msg_info "检测到上次使用的命令行环境变量，将自动复用" \
                     "Detected previously saved environment variables, will reuse"
            # 读取环境变量
            if load_env_from_file "$service_name"; then
                main_env="$SSM_MAIN"
                twin_env="$SSM_TWIN"
                
                # 显示将要使用的环境变量
                if [[ -n "$main_env" ]]; then
                    if [[ -n "$twin_env" ]]; then
                        msg_info "主服务环境变量: ${main_env}" "Main service env: ${main_env}"
                        msg_info "伴生服务环境变量: ${twin_env}" "Twin service env: ${twin_env}"
                    else
                        msg_info "环境变量: ${main_env}" "Environment variables: ${main_env}"
                    fi
                fi
                
                msg_notice "使用 -e '' 清空，或使用 reload 命令忽略" \
                           "Use -e '' to clear, or use reload command to ignore"
            else
                # 读取失败，已经在load_env_from_file 中警告过了
                main_env=""
                twin_env=""
            fi
        fi
    fi

    # 验证环境变量字符串格式与安全性
    if [[ -n "$main_env" ]] && ! validate_env_string_safe "$main_env"; then
        msg_error "主服务环境变量格式非法或包含危险字符" "Main service env format is invalid or contains unsafe characters"
        return ${EXIT_USAGE}
    fi
    if [[ -n "$twin_env" ]] && ! validate_env_string_safe "$twin_env"; then
        msg_error "伴生服务环境变量格式非法或包含危险字符" "Twin service env format is invalid or contains unsafe characters"
        return ${EXIT_USAGE}
    fi
    
    # 3. 加载配置
    load_global_config
    load_service_config "$service_name"
    
    # 设置当前服务上下文
    SSM_CURRENT_SERVICE="$service_name"
    SSM_CURRENT_SERVICE_DIR=$(get_service_dir "$service_name")
    
    # 4. 获取锁
    local lock_timeout="${SSM_GLOBAL_CONFIG[SSM_LOCK_TIMEOUT]}"
    if ! acquire_service_lock "$service_name" "$lock_timeout"; then
        msg_error "无法获取服务锁，可能有其他操作正在进行" "Cannot acquire service lock, another operation may be in progress"
        return ${EXIT_LOCK_FAILED}
    fi
    
    # 5. 双生子检测
    local twin_service
    twin_service="${SSM_SERVICE_CONFIG[SSM_TWIN]}"
    
    if [[ -n "$twin_service" ]]; then
        # 验证双生子配置
        if ! validate_twin_config "$service_name"; then
            msg_error "双生子配置无效:伴生服务 ${twin_service} 也配置了双生子" \
                      "Invalid twin configuration: twin service ${twin_service} also has a twin configured"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_TWIN_ERROR}
        fi
        
        # 检查伴生服务
        if ! service_exists "$twin_service"; then
            msg_error "伴生服务不存在: ${twin_service}" "Twin service does not exist: ${twin_service}"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_NOT_FOUND}
        fi
        
        if ! is_service_valid "$twin_service"; then
            msg_error "伴生服务无效: ${twin_service}" "Twin service is invalid: ${twin_service}"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_ERROR}
        fi

        # 获取伴生服务锁，避免并发竞态
        if ! acquire_service_lock "$twin_service" "$lock_timeout"; then
            msg_error "无法获取伴生服务锁，可能有其他操作正在进行" "Cannot acquire twin service lock, another operation may be in progress"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_LOCK_FAILED}
        fi
    else
        # 没有双生子，但提供了 twin_env
        if [[ -n "$twin_env" ]]; then
            msg_error "服务没有配置双生子，但提供了伴生服务的环境变量" \
                      "Service has no twin configured, but twin environment variables provided"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_USAGE}
        fi
    fi
    
    # 6. 执行 pre-restart 钩子
    if ! execute_hook "pre-restart" "$service_name"; then
        msg_error "pre-restart 钩子失败，取消重启" "pre-restart hook failed, aborting restart"
        log_history "RESTART" "$service_name" "FAILED" "pre-restart hook blocked"
        release_related_locks "$service_name" "$twin_service"
        return ${EXIT_HOOK_BLOCKED}
    fi
    
    # 7. 停止主服务（如果正在运行）
    local was_running=false
    if is_service_running "$service_name"; then
        was_running=true
        msg_info "停止服务..." "Stopping service..."
        
        local pid
        pid=$(read_service_pid "$service_name")
        
        if [[ -n "$pid" ]]; then
            # 执行 pre-stop 钩子
            if ! execute_hook "pre-stop" "$service_name"; then
                msg_warning "pre-stop 钩子失败" "pre-stop hook failed"
            fi
            
            # 停止进程
            local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
            local kill_process_group="${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}"
            
            if [[ "$kill_process_group" == "true" ]]; then
                if ! stop_process_group "$pid" "$stop_timeout"; then
                    msg_error "停止服务失败" "Failed to stop service"
                    log_history "RESTART" "$service_name" "FAILED" "stop failed"
                    release_related_locks "$service_name" "$twin_service"
                    return ${EXIT_ERROR}
                fi
            else
                if ! stop_process "$pid" "$stop_timeout"; then
                    msg_error "停止服务失败" "Failed to stop service"
                    log_history "RESTART" "$service_name" "FAILED" "stop failed"
                    release_related_locks "$service_name" "$twin_service"
                    return ${EXIT_ERROR}
                fi
            fi
            
            # 删除 PID 文件
            remove_service_pid "$service_name"
            
            # 执行 post-stop 钩子
            if ! execute_hook "post-stop" "$service_name"; then
                msg_warning "post-stop 钩子失败" "post-stop hook failed"
            fi
        fi
    else
        msg_info "服务未运行，直接启动" "Service is not running, starting directly"
    fi
    
    # 停止伴生服务（如果正在运行），避免后续启动阶段重复启动或端口冲突
    if [[ -n "$twin_service" ]] && is_service_running "$twin_service"; then
        msg_info "停止伴生服务: ${twin_service}" "Stopping twin service: ${twin_service}"
        
        local twin_pid
        twin_pid=$(read_service_pid "$twin_service")
        
        if [[ -n "$twin_pid" ]]; then
            local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
            local kill_process_group="${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}"
            
            if [[ "$kill_process_group" == "true" ]]; then
                if ! stop_process_group "$twin_pid" "$stop_timeout"; then
                    msg_warning "停止伴生服务失败: ${twin_service}" "Failed to stop twin service: ${twin_service}"
                fi
            else
                if ! stop_process "$twin_pid" "$stop_timeout"; then
                    msg_warning "停止伴生服务失败: ${twin_service}" "Failed to stop twin service: ${twin_service}"
                fi
            fi
            
            remove_service_pid "$twin_service"
        fi
    fi
    
    # 8. 执行 pre-start 钩子
    if ! execute_hook "pre-start" "$service_name"; then
        msg_error "pre-start 钩子失败，取消启动" "pre-start hook failed, aborting start"
        log_history "RESTART" "$service_name" "FAILED" "pre-start hook blocked"
        release_related_locks "$service_name" "$twin_service"
        return ${EXIT_HOOK_BLOCKED}
    fi
    
    # 9. 启动服务
    msg_info "启动服务..." "Starting service..."
    
    # 双生子启动逻辑
    local start_order
    start_order=$(get_twin_start_order "$service_name")
    local twin_required
    twin_required=$(is_twin_required "$service_name" && echo "true" || echo "false")
    
    if [[ -n "$twin_service" ]]; then
        if [[ "$start_order" == "twin_first" ]]; then
            # 先启动伴生服务
            msg_info "启动伴生服务: ${twin_service}" "Starting twin service: ${twin_service}"
            
            # 加载伴生服务配置
            load_service_config "$twin_service"
            
            if ! _start_single_service "$twin_service" "$twin_env"; then
                msg_error "伴生服务启动失败: ${twin_service}" "Failed to start twin service: ${twin_service}"
                if [[ "$twin_required" == "true" ]]; then
                    msg_error "伴生服务为必需，取消主服务启动" "Twin service is required, aborting main service start"
                    log_history "RESTART" "$service_name" "FAILED" "twin required but failed to start"
                    release_related_locks "$service_name" "$twin_service"
                    return ${EXIT_TWIN_ERROR}
                else
                    msg_warning "伴生服务启动失败，但继续启动主服务" "Twin service failed, but continuing with main service"
                fi
            fi
            
            # 重新加载主服务配置
            load_service_config "$service_name"
            
            # 再启动主服务
            msg_info "启动主服务: ${service_name}" "Starting main service: ${service_name}"
            if ! _start_single_service "$service_name" "$main_env"; then
                msg_error "主服务启动失败" "Failed to start main service"
                # 回滚：停止伴生服务
                if is_service_running "$twin_service"; then
                    msg_info "回滚: 停止伴生服务" "Rollback: stopping twin service"
                    local twin_pid
                    twin_pid=$(read_service_pid "$twin_service")
                    if [[ -n "$twin_pid" ]]; then
                        local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
                        if [[ "${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}" == "true" ]]; then
                            stop_process_group "$twin_pid" "$stop_timeout" || true
                        else
                            stop_process "$twin_pid" "$stop_timeout" || true
                        fi
                        remove_service_pid "$twin_service"
                    fi
                fi
                
                log_history "RESTART" "$service_name" "FAILED" "main service failed to start"
                release_related_locks "$service_name" "$twin_service"
                return ${EXIT_ERROR}
            fi
        else
            # main_first: 先启动主服务
            msg_info "启动主服务: ${service_name}" "Starting main service: ${service_name}"
            if ! _start_single_service "$service_name" "$main_env"; then
                msg_error "主服务启动失败" "Failed to start main service"
                log_history "RESTART" "$service_name" "FAILED" "main service failed to start"
                release_related_locks "$service_name" "$twin_service"
                return ${EXIT_ERROR}
            fi
            
            # 再启动伴生服务
            msg_info "启动伴生服务: ${twin_service}" "Starting twin service: ${twin_service}"
            
            # 加载伴生服务配置
            load_service_config "$twin_service"
            
            if ! _start_single_service "$twin_service" "$twin_env"; then
                msg_error "伴生服务启动失败: ${twin_service}" "Failed to start twin service: ${twin_service}"
                if [[ "$twin_required" == "true" ]]; then
                    msg_error "伴生服务为必需，回滚主服务" "Twin service is required, rolling back main service"
                    
                    # 回滚：停止主服务
                    local main_pid
                    main_pid=$(read_service_pid "$service_name")
                    if [[ -n "$main_pid" ]]; then
                        local stop_timeout="${SSM_GLOBAL_CONFIG[SSM_STOP_TIMEOUT]}"
                        if [[ "${SSM_GLOBAL_CONFIG[SSM_KILL_PROCESS_GROUP]}" == "true" ]]; then
                            stop_process_group "$main_pid" "$stop_timeout" || true
                        else
                            stop_process "$main_pid" "$stop_timeout" || true
                        fi
                        remove_service_pid "$service_name"
                    fi
                    log_history "RESTART" "$service_name" "FAILED" "twin required but failed to start"
                    release_related_locks "$service_name" "$twin_service"
                    return ${EXIT_TWIN_ERROR}
                else
                    msg_warning "伴生服务启动失败，但主服务已启动" "Twin service failed, but main service is running"
                fi
            fi
            
            # 重新加载主服务配置
            load_service_config "$service_name"
        fi
    else
        # 没有双生子，直接启动主服务
        if ! _start_single_service "$service_name" "$main_env"; then
            msg_error "服务启动失败" "Failed to start service"
            log_history "RESTART" "$service_name" "FAILED" "service failed to start"
            release_related_locks "$service_name" "$twin_service"
            return ${EXIT_ERROR}
        fi
    fi
    
    # 10. 执行 post-start 钩子
    if ! execute_hook "post-start" "$service_name"; then
        msg_warning "post-start 钩子失败" "post-start hook failed"
    fi
    
    # 11. 执行 post-restart 钩子
    if ! execute_hook "post-restart" "$service_name"; then
        msg_warning "post-restart 钩子失败" "post-restart hook failed"
    fi
    
    # 12. 处理 .ssm.env 文件
    if [[ "$clear_env_flag" == true ]]; then
        # 清空模式：删除 .ssm.env
        if has_env_file "$service_name"; then
            remove_env_file "$service_name"
            msg_info "已清空命令行环境变量" "Cleared command-line environment variables"
            msg_info "服务将使用配置文件中的环境变量（如果有）" \
                     "Service will use environment variables from config file (if any)"
        fi
    elif [[ "$user_specified_env" == true ]]; then
        # 用户指定了 -e 参数（非清空模式）：保存到 .ssm.env
        if [[ -n "$main_env" ]] || [[ -n "$twin_env" ]]; then
            save_env_to_file "$service_name" "$main_env" "$twin_env"
        fi
    fi
    # 如果是自动复用模式，不修改 .ssm.env 文件
    
    # 13. 记录历史
    local pid
    pid=$(read_service_pid "$service_name")
    local details="pid=${pid}"
    if [[ -n "$main_env" ]] || [[ -n "$twin_env" ]]; then
        details="${details} with_env=true"
    fi
    log_history "RESTART" "$service_name" "OK" "$details"
    log_manager "info" "Service restarted: ${service_name} (PID: ${pid})"
    
    # 显示成功消息
    msg_success "服务 '${service_name}' 重启成功 (PID: ${pid})" \
                "Service '${service_name}' restarted successfully (PID: ${pid})"
    
    if [[ -n "$twin_service" ]]; then
        local twin_pid
        twin_pid=$(read_service_pid "$twin_service" 2>/dev/null || echo "N/A")
        msg_info "伴生服务 '${twin_service}' (PID: ${twin_pid})" \
                 "Twin service '${twin_service}' (PID: ${twin_pid})"
    fi
    
    # 14. 释放锁
    release_related_locks "$service_name" "$twin_service"
    
    return ${EXIT_SUCCESS}
}


# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - status
# ═══════════════════════════════════════════════════════════════════════════

function cmd_status() {
    local service_name=""
    
    # 解析参数
    if [[ $# -gt 0 ]]; then
        service_name="$1"
    fi
    
    if [[ -z "$service_name" ]]; then
        # 显示所有服务状态（列表）
        _show_all_services_status
    else
        # 显示指定服务详细状态
        _show_service_detail_status "$service_name"
    fi
}

# 内部函数：显示所有服务状态（列表格式）
function _show_all_services_status() {
    # 检查是否已初始化
    if ! is_ssm_initialized; then
        msg_error "SSM 未初始化，请先运行: ssm init" "SSM is not initialized. Please run: ssm init"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 获取所有服务
    local all_services
    mapfile -t all_services < <(get_all_services)
    
    if [[ ${#all_services[@]} -eq 0 ]]; then
        msg_info "没有找到任何服务" "No services found"
        return ${EXIT_SUCCESS}
    fi
    
    # 统计
    local total_count=0
    local running_count=0
    local stopped_count=0
    local dead_count=0
    local invalid_count=0
    
    # 构建服务列表项
    local service_items=()
    
    for service in "${all_services[@]}"; do
        total_count=$((total_count + 1))
        
        # 获取服务状态
        local status
        status=$(get_service_status "$service")
        
        # 获取状态符号和颜色
        local status_symbol
        local status_text
        case "$status" in
            "$SERVICE_STATUS_RUNNING")
                status_symbol="●"
                status_text="running"
                running_count=$((running_count + 1))
                ;;
            "$SERVICE_STATUS_STOPPED")
                status_symbol="○"
                status_text="stopped"
                stopped_count=$((stopped_count + 1))
                ;;
            "$SERVICE_STATUS_DEAD")
                status_symbol="⚠"
                status_text="dead"
                dead_count=$((dead_count + 1))
                ;;
            "$SERVICE_STATUS_INVALID")
                status_symbol="✗"
                status_text="invalid"
                invalid_count=$((invalid_count + 1))
                ;;
        esac
        
        # 获取额外信息
        local extra_info=""
        if [[ "$status" == "$SERVICE_STATUS_RUNNING" ]]; then
            local pid
            pid=$(read_service_pid "$service")
            local uptime
            uptime=$(get_process_uptime "$pid")
            extra_info="PID: ${pid}, Uptime: ${uptime}"
        elif [[ "$status" == "$SERVICE_STATUS_DEAD" ]]; then
            extra_info="(stale PID file)"
        fi
        
        # 检查是否为链接
        local link_info=""
        if is_service_link "$service"; then
            local target
            target=$(readlink "$(get_service_dir "$service")")
            link_info=" 🔗 -> ${target}"
        fi
        
        # 构建列表项
        local item="${status_symbol} ${service}  [${status_text}]"
        if [[ -n "$extra_info" ]]; then
            item="${item}  ${extra_info}"
        fi
        if [[ -n "$link_info" ]]; then
            item="${item}${link_info}"
        fi
        
        service_items+=("$item")
    done
    
    # 使用 msg_list 显示列表
    msg_list "${service_items[@]}"
    
    # 显示统计信息
    echo ""
    msg_info "总计: ${total_count} 个服务 | ${running_count} 运行中 | ${stopped_count} 已停止 | ${dead_count} 僵死 | ${invalid_count} 无效" \
             "Total: ${total_count} services | ${running_count} running | ${stopped_count} stopped | ${dead_count} dead | ${invalid_count} invalid"
    
    return ${EXIT_SUCCESS}
}

# 内部函数：显示服务详细状态
# 参数: $1 - 服务名
function _show_service_detail_status() {
    local service_name="$1"
    
    # 验证服务是否存在
    if ! service_exists "$service_name"; then
        msg_error "服务不存在: ${service_name}" "Service does not exist: ${service_name}"
        return ${EXIT_NOT_FOUND}
    fi
    
    # 获取服务状态
    local status
    status=$(get_service_status "$service_name")
    
    # 加载配置获取描述和端口信息
    load_service_config "$service_name"
    
    # 获取服务目录
    local service_dir
    service_dir=$(get_service_dir "$service_name")
    
    # 构建详细信息列表
    local detail_items=()
    
    # 服务名称
    detail_items+=("服务名称 / Service Name: ${service_name}")
    
    # 服务描述
    local description="${SSM_SERVICE_CONFIG[SSM_SERVICE_DESCRIPTION]}"
    if [[ -n "$description" ]]; then
        detail_items+=("描述 / Description: ${description}")
    fi
    
    # 服务状态
    local status_symbol
    local status_display
    case "$status" in
        "$SERVICE_STATUS_RUNNING")
            status_symbol="●"
            status_display="运行中 / running"
            ;;
        "$SERVICE_STATUS_STOPPED")
            status_symbol="○"
            status_display="已停止 / stopped"
            ;;
        "$SERVICE_STATUS_DEAD")
            status_symbol="⚠"
            status_display="僵死 / dead (PID文件存在但进程不存在 / PID file exists but process is dead)"
            ;;
        "$SERVICE_STATUS_INVALID")
            status_symbol="✗"
            status_display="无效 / invalid (缺少start.sh / missing start.sh)"
            ;;
    esac
    detail_items+=("状态 / Status: ${status_symbol} ${status_display}")
    
    # PID 和运行时长
    if [[ "$status" == "$SERVICE_STATUS_RUNNING" ]]; then
        local pid
        pid=$(read_service_pid "$service_name")
        detail_items+=("PID: ${pid}")
        
        local uptime
        uptime=$(get_process_uptime "$pid")
        detail_items+=("运行时长 / Uptime: ${uptime}")
    fi
    
    # 服务端口
    local port="${SSM_SERVICE_CONFIG[SSM_SERVICE_PORT]}"
    if [[ -n "$port" ]]; then
        detail_items+=("端口 / Port: ${port}")
    fi
    
    # 服务目录
    detail_items+=("服务目录 / Directory: ${service_dir}")
    
    # 是否为链接
    if is_service_link "$service_name"; then
        local target
        target=$(readlink "$service_dir")
        detail_items+=("链接目标 / Link Target: ${target}")
    fi
    
    # 双生子信息
    local twin_service="${SSM_SERVICE_CONFIG[SSM_TWIN]}"
    if [[ -n "$twin_service" ]]; then
        local twin_order="${SSM_SERVICE_CONFIG[SSM_TWIN_START_ORDER]}"
        local twin_stop="${SSM_SERVICE_CONFIG[SSM_TWIN_STOP_TOGETHER]}"
        local twin_require="${SSM_SERVICE_CONFIG[SSM_TWIN_REQUIRE]}"
        
        detail_items+=("伴生服务 / Twin: ${twin_service}")
        detail_items+=("  启动顺序 / Start Order: ${twin_order}")
        detail_items+=("  连带停止 / Stop Together: ${twin_stop}")
        detail_items+=("  必需 / Required: ${twin_require}")
        
        # 显示伴生服务状态
        if service_exists "$twin_service"; then
            local twin_status
            twin_status=$(get_service_status "$twin_service")
            local twin_status_symbol
            case "$twin_status" in
                "$SERVICE_STATUS_RUNNING")
                    twin_status_symbol="●"
                    ;;
                "$SERVICE_STATUS_STOPPED")
                    twin_status_symbol="○"
                    ;;
                "$SERVICE_STATUS_DEAD")
                    twin_status_symbol="⚠"
                    ;;
                "$SERVICE_STATUS_INVALID")
                    twin_status_symbol="✗"
                    ;;
            esac
            detail_items+=("  伴生服务状态 / Twin Status: ${twin_status_symbol} ${twin_status}")
        fi
    fi
    
    # 日志文件
    local out_log
    out_log=$(get_service_out_log "$service_name")
    local err_log
    err_log=$(get_service_err_log "$service_name")
    
    detail_items+=("输出日志 / Output Log: ${out_log}")
    if [[ "${SSM_GLOBAL_CONFIG[SSM_OUTPUT_MODE]}" == "separate" ]]; then
        detail_items+=("错误日志 / Error Log: ${err_log}")
    fi
    
    # 使用 msg_list 显示详细信息
    msg_list "${detail_items[@]}"
    
    return ${EXIT_SUCCESS}
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - list
# ═══════════════════════════════════════════════════════════════════════════

function cmd_list() {
    # 检查是否已初始化
    if ! is_ssm_initialized; then
        msg_error "SSM 未初始化，请先运行: ssm init" "SSM is not initialized. Please run: ssm init"
        return ${EXIT_INIT_ERROR}
    fi
    
    # 获取所有服务
    local all_services
    mapfile -t all_services < <(get_all_services)
    
    if [[ ${#all_services[@]} -eq 0 ]]; then
        msg_info "没有找到任何服务" "No services found"
        return ${EXIT_SUCCESS}
    fi
    
    # 统计
    local running_count=0
    local stopped_count=0
    
    # 构建服务列表项
    local service_items=()
    local use_color
    if should_use_color; then
        use_color=true
    else
        use_color=false
    fi
    
    for service in "${all_services[@]}"; do
        # 获取服务状态
        local status
        status=$(get_service_status "$service")
        
        # 获取状态符号、文本和颜色
        local status_symbol
        local status_text
        local status_color
        case "$status" in
            "$SERVICE_STATUS_RUNNING")
                status_symbol="●"
                status_text="running"
                status_color="$COLOR_BOLD_GREEN"
                running_count=$((running_count + 1))
                ;;
            "$SERVICE_STATUS_STOPPED")
                status_symbol="●"
                status_text="stopped"
                status_color="$COLOR_GRAY"
                stopped_count=$((stopped_count + 1))
                ;;
            "$SERVICE_STATUS_DEAD")
                status_symbol="●"
                status_text="dead"
                status_color="$COLOR_BOLD_RED"
                stopped_count=$((stopped_count + 1))
                ;;
            "$SERVICE_STATUS_INVALID")
                status_symbol="●"
                status_text="invalid"
                status_color="$COLOR_BOLD_YELLOW"
                stopped_count=$((stopped_count + 1))
                ;;
        esac
        
        # 加载配置获取描述
        load_service_config "$service"
        local description="${SSM_SERVICE_CONFIG[SSM_SERVICE_DESCRIPTION]}"
        
        # 构建多行列表项，每个信息独占一行
        local item=""
        
        if [[ "$use_color" == true ]]; then
            # 第一行：状态符号 + 服务名 + 状态文本，带颜色
            item+="${status_color}${status_symbol}${COLOR_RESET} "
            item+="${COLOR_WHITE}${service}${COLOR_RESET} "
            item+="${status_color}[${status_text}]${COLOR_RESET}"
            
            # 描述
            if [[ -n "$description" ]]; then
                item+=$'\n'"    ${COLOR_CYAN}${description}${COLOR_RESET}"
            fi
            
            # 运行信息：PID 和 Uptime 分开两行
            if [[ "$status" == "$SERVICE_STATUS_RUNNING" ]]; then
                local pid
                pid=$(read_service_pid "$service")
                local uptime
                uptime=$(get_process_uptime "$pid")
                item+=$'\n'"    ${COLOR_GRAY}PID: ${pid}${COLOR_RESET}"
                item+=$'\n'"    ${COLOR_GRAY}Uptime: ${uptime}${COLOR_RESET}"
            elif [[ "$status" == "$SERVICE_STATUS_DEAD" ]]; then
                item+=$'\n'"    ${COLOR_BOLD_YELLOW}(stale PID file)${COLOR_RESET}"
            fi
            
            # 链接信息
            if is_service_link "$service"; then
                local target
                target=$(readlink "$(get_service_dir "$service")")
                item+=$'\n'"    ${COLOR_MAGENTA}🔗 -> ${target}${COLOR_RESET}"
            fi
        else
            # 无颜色模式
            item+="${status_symbol} ${service} [${status_text}]"
            if [[ -n "$description" ]]; then
                item+=$'\n'"    ${description}"
            fi
            
            if [[ "$status" == "$SERVICE_STATUS_RUNNING" ]]; then
                local pid
                pid=$(read_service_pid "$service")
                local uptime
                uptime=$(get_process_uptime "$pid")
                item+=$'\n'"    PID: ${pid}"
                item+=$'\n'"    Uptime: ${uptime}"
            elif [[ "$status" == "$SERVICE_STATUS_DEAD" ]]; then
                item+=$'\n'"    (stale PID file)"
            fi
            
            if is_service_link "$service"; then
                local target
                target=$(readlink "$(get_service_dir "$service")")
                item+=$'\n'"    🔗 -> ${target}"
            fi
        fi
        
        service_items+=("$item")
    done
    
    # 使用 msg_list 显示列表（内部用echo 输出，需改用 echo -e 支持颜色转义）
    print_separator
    for item in "${service_items[@]}"; do
        echo -e "$item"
    done
    print_separator
    
    # 显示统计信息
    echo ""
    msg_info "找到 ${#all_services[@]} 个服务 (${running_count} 运行中, ${stopped_count} 已停止)" "Found ${#all_services[@]} services (${running_count} running, ${stopped_count} stopped)"
    
    return ${EXIT_SUCCESS}
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - log-rotate
# ═══════════════════════════════════════════════════════════════════════════

function cmd_log_rotate() {
    # 检查是否已初始化
    if ! is_ssm_initialized; then
        msg_error "SSM 未初始化，请先运行: ssm init" "SSM is not initialized. Please run: ssm init"
        return ${EXIT_INIT_ERROR}
    fi
    
    msg_info "开始日志轮转..." "Starting log rotation..."
    
    local rotated_count=0
    
    # 1. 轮转 manager.log
    local manager_log
    manager_log=$(get_manager_log)
    if [[ -f "$manager_log" ]]; then
        msg_info "轮转管理器日志..." "Rotating manager log..."
        if rotate_log_file "$manager_log"; then
            rotated_count=$((rotated_count + 1))
        fi
    fi
    
    # 2. 轮转 history.log
    local history_log
    history_log=$(get_history_log)
    if [[ -f "$history_log" ]]; then
        msg_info "轮转历史日志..." "Rotating history log..."
        if rotate_log_file "$history_log"; then
            rotated_count=$((rotated_count + 1))
        fi
    fi
    
    # 3. 轮转所有服务日志
    local all_services
    mapfile -t all_services < <(get_all_services)
    
    for service in "${all_services[@]}"; do
        local out_log
        out_log=$(get_service_out_log "$service")
        if [[ -f "$out_log" ]]; then
            msg_info "轮转服务日志: ${service}.out" "Rotating service log: ${service}.out"
            if rotate_log_file "$out_log"; then
                rotated_count=$((rotated_count + 1))
            fi
        fi
        
        local err_log
        err_log=$(get_service_err_log "$service")
        if [[ -f "$err_log" ]]; then
            msg_info "轮转服务日志: ${service}.err" "Rotating service log: ${service}.err"
            if rotate_log_file "$err_log"; then
                rotated_count=$((rotated_count + 1))
            fi
        fi
    done
    
    # 4. 清理过期日志
    msg_info "清理过期日志..." "Cleaning up old logs..."
    cleanup_old_logs
    
    msg_success "日志轮转完成，处理了 ${rotated_count} 个日志文件" \
                "Log rotation completed, processed ${rotated_count} log files"
    
    log_history "LOG_ROTATE" "system" "OK" "rotated ${rotated_count} files"
    log_manager "info" "Log rotation completed"
    
    return ${EXIT_SUCCESS}
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - logs
# ═══════════════════════════════════════════════════════════════════════════

function cmd_logs() {
    local subcmd="show"
    if [[ $# -gt 0 ]] && [[ "$1" == "rotate" ]]; then
        shift
        cmd_log_rotate "$@"
        return $?
    fi

    local target=""
    local mode="tail"      # tail/head
    local lines=50
    local backend="auto"   # auto/native/sed
    local log_type="out"   # out/err

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --mode)
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 --mode 需要参数 (tail/head)" "Option --mode requires an argument (tail/head)"
                    return ${EXIT_USAGE}
                fi
                mode="$2"
                shift 2
                ;;
            --lines|-n)
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 --lines 需要参数" "Option --lines requires an argument"
                    return ${EXIT_USAGE}
                fi
                lines="$2"
                shift 2
                ;;
            --backend)
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 --backend 需要参数 (auto/native/sed)" "Option --backend requires an argument (auto/native/sed)"
                    return ${EXIT_USAGE}
                fi
                backend="$2"
                shift 2
                ;;
            --type)
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 --type 需要参数 (out/err)" "Option --type requires an argument (out/err)"
                    return ${EXIT_USAGE}
                fi
                log_type="$2"
                shift 2
                ;;
            -*)
                msg_error "未知选项: $1" "Unknown option: $1"
                return ${EXIT_USAGE}
                ;;
            *)
                if [[ -z "$target" ]]; then
                    target="$1"
                else
                    msg_error "多余参数: $1" "Extra argument: $1"
                    return ${EXIT_USAGE}
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$target" ]]; then
        msg_error "缺少日志目标（服务名|manager|history）" "Missing log target (service|manager|history)"
        return ${EXIT_USAGE}
    fi

    if [[ ! "$lines" =~ ^[0-9]+$ ]] || [[ "$lines" -le 0 ]]; then
        msg_error "--lines 必须是正整数" "--lines must be a positive integer"
        return ${EXIT_USAGE}
    fi

    if [[ "$mode" != "tail" ]] && [[ "$mode" != "head" ]]; then
        msg_error "--mode 只支持 tail 或 head" "--mode supports only tail or head"
        return ${EXIT_USAGE}
    fi

    if [[ "$backend" != "auto" ]] && [[ "$backend" != "native" ]] && [[ "$backend" != "sed" ]]; then
        msg_error "--backend 只支持 auto/native/sed" "--backend supports only auto/native/sed"
        return ${EXIT_USAGE}
    fi

    if [[ "$log_type" != "out" ]] && [[ "$log_type" != "err" ]]; then
        msg_error "--type 只支持 out 或 err" "--type supports only out or err"
        return ${EXIT_USAGE}
    fi

    local log_file=""
    case "$target" in
        manager)
            log_file=$(get_manager_log)
            ;;
        history)
            log_file=$(get_history_log)
            ;;
        *)
            if ! service_exists "$target"; then
                msg_error "服务不存在: ${target}" "Service does not exist: ${target}"
                return ${EXIT_NOT_FOUND}
            fi
            if [[ "$log_type" == "err" ]]; then
                log_file=$(get_service_err_log "$target")
            else
                log_file=$(get_service_out_log "$target")
            fi
            ;;
    esac

    if [[ ! -f "$log_file" ]]; then
        msg_error "日志文件不存在: ${log_file}" "Log file does not exist: ${log_file}"
        return ${EXIT_NOT_FOUND}
    fi

    local actual_backend="$backend"
    if [[ "$actual_backend" == "auto" ]]; then
        actual_backend="native"
        if [[ "$mode" == "tail" ]] && ! command -v tail >/dev/null 2>&1; then
            actual_backend="sed"
        fi
        if [[ "$mode" == "head" ]] && ! command -v head >/dev/null 2>&1; then
            actual_backend="sed"
        fi
    fi

    msg_info "日志文件: ${log_file}" "Log file: ${log_file}"
    msg_info "模式: ${mode} | 行数: ${lines} | 后端: ${actual_backend}" "Mode: ${mode} | Lines: ${lines} | Backend: ${actual_backend}"
    print_separator

    if [[ "$actual_backend" == "sed" ]]; then
        if [[ "$mode" == "tail" ]]; then
            file_tail_sed "$log_file" "$lines"
        else
            file_head_sed "$log_file" "$lines"
        fi
    else
        if [[ "$mode" == "tail" ]]; then
            tail -n "$lines" "$log_file"
        else
            head -n "$lines" "$log_file"
        fi
    fi

    return ${EXIT_SUCCESS}
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - prune
# ═══════════════════════════════════════════════════════════════════════════

function cmd_prune() {
    local use_all=false
    local clean_env=false
    local clean_logs=false
    local services=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all)
                use_all=true
                shift
                ;;
            --env)
                clean_env=true
                shift
                ;;
            --logs)
                clean_logs=true
                shift
                ;;
            -*)
                msg_error "未知选项: $1" "Unknown option: $1"
                return ${EXIT_USAGE}
                ;;
            *)
                services+=("$1")
                shift
                ;;
        esac
    done

    if [[ "$use_all" != "true" ]] && [[ ${#services[@]} -eq 0 ]]; then
        msg_error "请传入服务名，或使用 --all" "Please pass service names, or use --all"
        return ${EXIT_USAGE}
    fi

    if [[ "$use_all" == "true" ]]; then
        mapfile -t services < <(get_all_services)
    fi

    local pruned_dead=0
    local pruned_env=0
    local pruned_logs=0
    local service
    for service in "${services[@]}"; do
        if ! service_exists "$service"; then
            msg_warning "跳过不存在的服务: ${service}" "Skipping non-existing service: ${service}"
            continue
        fi

        local pid
        pid=$(read_service_pid "$service" 2>/dev/null || true)
        if [[ -n "$pid" ]] && ! is_same_service_process "$service" "$pid"; then
            remove_service_pid "$service"
            pruned_dead=$((pruned_dead + 1))
            msg_info "已清理 dead pid: ${service}" "Cleaned dead pid: ${service}"
        fi

        if [[ "$clean_env" == "true" ]] && has_env_file "$service"; then
            remove_env_file "$service"
            pruned_env=$((pruned_env + 1))
        fi

        if [[ "$clean_logs" == "true" ]]; then
            local out_log
            out_log=$(get_service_out_log "$service")
            local err_log
            err_log=$(get_service_err_log "$service")
            rm -f "$out_log" "$err_log" 2>/dev/null || true
            pruned_logs=$((pruned_logs + 1))
        fi
    done

    msg_success "prune 完成" "Prune completed"
    msg_info "dead pid: ${pruned_dead}" "dead pid: ${pruned_dead}"
    if [[ "$clean_env" == "true" ]]; then
        msg_info "env 文件: ${pruned_env}" "env files: ${pruned_env}"
    fi
    if [[ "$clean_logs" == "true" ]]; then
        msg_info "日志集合: ${pruned_logs}" "log sets: ${pruned_logs}"
    fi

    return ${EXIT_SUCCESS}
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - check
# ═══════════════════════════════════════════════════════════════════════════

function cmd_check() {
    local use_all=false
    local services=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all)
                use_all=true
                shift
                ;;
            -*)
                msg_error "未知选项: $1" "Unknown option: $1"
                return ${EXIT_USAGE}
                ;;
            *)
                services+=("$1")
                shift
                ;;
        esac
    done

    if [[ "$use_all" != "true" ]] && [[ ${#services[@]} -eq 0 ]]; then
        msg_error "请传入服务名，或使用 --all" "Please pass service names, or use --all"
        return ${EXIT_USAGE}
    fi

    if [[ "$use_all" == "true" ]]; then
        mapfile -t services < <(get_all_services)
    fi

    local has_error=false
    local service
    for service in "${services[@]}"; do
        if ! service_exists "$service"; then
            msg_error "[${service}] 服务不存在" "[${service}] Service does not exist"
            has_error=true
            continue
        fi

        msg_info "检查服务: ${service}" "Checking service: ${service}"
        local service_dir
        service_dir=$(get_service_dir "$service")
        local start_script
        start_script=$(get_service_start_script "$service")
        local config_file
        config_file=$(get_service_config_file "$service")

        if [[ ! -f "$start_script" ]]; then
            msg_error "  - 缺少 start.sh" "  - Missing start.sh"
            has_error=true
        elif [[ ! -x "$start_script" ]]; then
            msg_warning "  - start.sh 不可执行" "  - start.sh is not executable"
        else
            msg_success "  - start.sh OK" "  - start.sh OK"
        fi

        if [[ ! -f "$config_file" ]]; then
            msg_warning "  - 缺少 .ssm.conf" "  - Missing .ssm.conf"
        else
            msg_success "  - .ssm.conf OK" "  - .ssm.conf OK"
        fi

        load_service_config "$service"
        local twin="${SSM_SERVICE_CONFIG[SSM_TWIN]}"
        if [[ -n "$twin" ]]; then
            if ! service_exists "$twin"; then
                msg_error "  - twin 不存在: ${twin}" "  - Twin service missing: ${twin}"
                has_error=true
            elif ! validate_twin_config "$service"; then
                msg_error "  - twin 配置冲突（双向配置）" "  - Twin config conflict (bi-directional)"
                has_error=true
            else
                msg_success "  - twin 配置 OK" "  - Twin config OK"
            fi
        fi

        local pid
        pid=$(read_service_pid "$service" 2>/dev/null || true)
        if [[ -n "$pid" ]]; then
            if is_same_service_process "$service" "$pid"; then
                msg_success "  - PID 状态 OK (${pid})" "  - PID state OK (${pid})"
            else
                msg_warning "  - stale PID (${pid})" "  - stale PID (${pid})"
            fi
        else
            msg_info "  - 无 PID 文件" "  - No PID file"
        fi

        if has_env_file "$service"; then
            local env_file
            env_file=$(get_service_env_file "$service")
            local perms
            perms=$(stat -c "%a" "$env_file" 2>/dev/null || echo "")
            if [[ "$perms" == "600" ]]; then
                msg_success "  - .ssm.env 权限 OK (600)" "  - .ssm.env permission OK (600)"
            else
                msg_warning "  - .ssm.env 权限建议 600 (当前: ${perms})" "  - .ssm.env permission should be 600 (current: ${perms})"
            fi
        fi

        if [[ ! -d "$service_dir" ]]; then
            msg_error "  - 服务目录不可访问" "  - Service directory not accessible"
            has_error=true
        fi
    done

    if [[ "$has_error" == "true" ]]; then
        return ${EXIT_ERROR}
    fi
    return ${EXIT_SUCCESS}
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - install
# ═══════════════════════════════════════════════════════════════════════════

function cmd_install() {
    local install_name="ssm"
    local install_dir="${HOME}/.local/bin"
    local user_specified_name=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 --name 需要参数" "Option --name requires an argument"
                    return ${EXIT_USAGE}
                fi
                install_name="$2"
                user_specified_name=true
                shift 2
                ;;
            --dir)
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 --dir 需要参数" "Option --dir requires an argument"
                    return ${EXIT_USAGE}
                fi
                install_dir="$2"
                shift 2
                ;;
            *)
                msg_error "未知选项: $1" "Unknown option: $1"
                return ${EXIT_USAGE}
                ;;
        esac
    done

    if [[ ! "$install_name" =~ ^[a-zA-Z0-9._-]+$ ]]; then
        msg_error "安装名称不合法: ${install_name}" "Invalid install name: ${install_name}"
        return ${EXIT_USAGE}
    fi

    mkdir -p "$install_dir"

    # 默认安装名自动择优：ssm -> 版本名(如 ssm5) -> 交互选择覆盖
    if [[ "$user_specified_name" != "true" ]]; then
        local ssm_path="${install_dir}/ssm"
        if [[ -e "$ssm_path" ]]; then
            local versioned_name=""
            if [[ "$CURRENT_SCRIPT_NAME" =~ ^ssm[0-9]+$ ]]; then
                versioned_name="$CURRENT_SCRIPT_NAME"
            else
                local major
                major="${SSM_VERSION%%.*}"
                if [[ "$major" =~ ^[0-9]+$ ]]; then
                    versioned_name="ssm${major}"
                fi
            fi

            if [[ -n "$versioned_name" ]] && [[ ! -e "${install_dir}/${versioned_name}" ]]; then
                install_name="$versioned_name"
                msg_info "检测到 ssm 已存在，改用安装名: ${install_name}" \
                         "Detected existing ssm, switching install name to: ${install_name}"
            else
                local candidates=()
                local f
                for f in "$install_dir"/ssm*; do
                    [[ -e "$f" ]] || continue
                    candidates+=("$(basename "$f")")
                done

                if [[ ${#candidates[@]} -eq 0 ]]; then
                    candidates+=("ssm")
                fi

                if is_chinese; then
                    msg_warning "ssm 与版本名都已存在，需要选择一个已安装版本覆盖" \
                                "ssm and versioned name already exist, choose one installed version to overwrite"
                    msg_notice "可选文件:" "Available files:"
                else
                    msg_warning "ssm and versioned name already exist, choose one installed version to overwrite" \
                                "ssm and versioned name already exist, choose one installed version to overwrite"
                    msg_notice "Available files:" "Available files:"
                fi

                local i=1
                for f in "${candidates[@]}"; do
                    echo "  ${i}) ${f}"
                    i=$((i + 1))
                done
                echo "  ${i}) cancel"

                local choice
                read -r -p "> " choice
                if [[ -z "$choice" ]] || [[ ! "$choice" =~ ^[0-9]+$ ]]; then
                    msg_error "无效选择" "Invalid selection"
                    return ${EXIT_USAGE}
                fi

                if [[ "$choice" -eq "$i" ]]; then
                    msg_warning "已取消安装" "Installation cancelled"
                    return ${EXIT_ERROR}
                fi

                if [[ "$choice" -lt 1 ]] || [[ "$choice" -gt ${#candidates[@]} ]]; then
                    msg_error "无效选择" "Invalid selection"
                    return ${EXIT_USAGE}
                fi

                install_name="${candidates[$((choice - 1))]}"
                msg_info "将覆盖: ${install_name}" "Will overwrite: ${install_name}"
            fi
        fi
    fi

    local target_path="${install_dir}/${install_name}"

    if cp -f "$0" "$target_path"; then
        chmod +x "$target_path"
        msg_success "安装完成: ${target_path}" "Installed: ${target_path}"
        msg_notice "建议将目录加入 PATH: ${install_dir}" "Consider adding to PATH: ${install_dir}"
        return ${EXIT_SUCCESS}
    fi

    msg_error "安装失败: ${target_path}" "Install failed: ${target_path}"
    return ${EXIT_ERROR}
}

# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - enable / disable
# ═══════════════════════════════════════════════════════════════════════════

function cmd_enable() {
    local service_name=""
    if [[ $# -eq 0 ]]; then
        msg_error "缺少服务名" "Missing service name"
        return ${EXIT_USAGE}
    fi
    service_name="$1"

    if ! service_exists "$service_name"; then
        msg_error "服务不存在: ${service_name}" "Service does not exist: ${service_name}"
        return ${EXIT_NOT_FOUND}
    fi

    if ! is_service_valid "$service_name"; then
        msg_error "服务无效: 缺少可执行的 start.sh" "Service is invalid: missing executable start.sh"
        return ${EXIT_ERROR}
    fi

    load_global_config
    set_service_enable_flag "$service_name" "true"
    rebuild_enabled_script

    if ! ensure_enable_hook_registered; then
        msg_warning "自动启动入口未写入 shell 启动文件，请手动配置" \
                    "Autostart hook not written to shell startup file, configure manually"
    fi

    msg_success "已启用服务自动启动: ${service_name}" "Enabled autostart for service: ${service_name}"
    msg_info "可手动编辑服务的 .ssm.conf 调整启动行为" "You can edit service .ssm.conf to adjust startup behavior"
    return ${EXIT_SUCCESS}
}

function cmd_disable() {
    local service_name=""
    if [[ $# -eq 0 ]]; then
        msg_error "缺少服务名" "Missing service name"
        return ${EXIT_USAGE}
    fi
    service_name="$1"

    if ! service_exists "$service_name"; then
        msg_error "服务不存在: ${service_name}" "Service does not exist: ${service_name}"
        return ${EXIT_NOT_FOUND}
    fi

    load_global_config
    set_service_enable_flag "$service_name" "false"
    rebuild_enabled_script
    maybe_cleanup_enable_hook

    msg_success "已禁用服务自动启动: ${service_name}" "Disabled autostart for service: ${service_name}"
    msg_info "可手动编辑服务的 .ssm.conf 调整启动行为" "You can edit service .ssm.conf to adjust startup behavior"
    return ${EXIT_SUCCESS}
}


# ═══════════════════════════════════════════════════════════════════════════
# 核心命令实现 - help
# ═══════════════════════════════════════════════════════════════════════════

function cmd_help() {
    local command=""
    
    # 解析参数
    if [[ $# -gt 0 ]]; then
        command="$1"
    fi
    
    # 特殊处理 * / all / tree
    if [[ "$command" == "*" ]] || [[ "$command" == "all" ]]; then
        _show_all_commands_help
        return ${EXIT_SUCCESS}
    fi

    if [[ "$command" == "tree" ]]; then
        _show_command_tree_help
        return ${EXIT_SUCCESS}
    fi
    
    if [[ -z "$command" ]]; then
        # 显示总体帮助
        _show_general_help
    else
        # 显示特定命令帮助
        _show_command_help "$command"
    fi
}

# 内部函数：显示总体帮助
function _show_general_help() {
    local help_items=()
    
    help_items+=("${SSM_NAME} ${SSM_VERSION}")
    help_items+=("")
    
    if is_chinese; then
        help_items+=("用法:")
        help_items+=("  ${CURRENT_SCRIPT_NAME} [-u|--user <username>] [-r|--run-as <username>] <command> [options] [arguments]")
        help_items+=("")
        help_items+=("全局选项:")
        help_items+=("  -u, --user <username>  指定目标用户（默认当前用户）")
        help_items+=("  -r, --run-as <username>  指定执行身份（默认当前用户）")
        help_items+=("  -h, --help             显示帮助信息")
        help_items+=("  -v, --version          显示版本信息")
        help_items+=("")
        help_items+=("可用命令:")
        help_items+=("  init           初始化 SSM")
        help_items+=("  create         创建新服务")
        help_items+=("  start          启动服务")
        help_items+=("  stop           停止服务")
        help_items+=("  restart        重启服务")
        help_items+=("  reload         重新加载配置并重启")
        help_items+=("  status         查看服务状态")
        help_items+=("  list           列出所有服务")
        help_items+=("  logs           查看日志 / 日志轮转子命令")
        help_items+=("  prune          清理陈旧状态（默认仅 dead pid）")
        help_items+=("  check          静态检查服务")
        help_items+=("  log-rotate     手动日志轮转（兼容入口）")
        help_items+=("  install        安装 ssm 到 bin")
        help_items+=("  enable         启用服务自动启动")
        help_items+=("  disable        禁用服务自动启动")
        help_items+=("  help           显示帮助信息")
        help_items+=("")
        help_items+=("获取命令详细帮助:")
        help_items+=("  ${CURRENT_SCRIPT_NAME} help <command>")
        help_items+=("  ${CURRENT_SCRIPT_NAME} help all          显示所有命令的详细帮助")
        help_items+=("  ${CURRENT_SCRIPT_NAME} help *            同上")
        help_items+=("  ${CURRENT_SCRIPT_NAME} help tree         以树状图显示命令结构")
    else
        help_items+=("Usage:")
        help_items+=("  ${CURRENT_SCRIPT_NAME} [-u|--user <username>] [-r|--run-as <username>] <command> [options] [arguments]")
        help_items+=("")
        help_items+=("Global Options:")
        help_items+=("  -u, --user <username>  Specify target user (default: current user)")
        help_items+=("  -r, --run-as <username>  Specify execution identity (default: current user)")
        help_items+=("  -h, --help             Show help message")
        help_items+=("  -v, --version          Show version")
        help_items+=("")
        help_items+=("Available Commands:")
        help_items+=("  init           Initialize SSM")
        help_items+=("  create         Create a new service")
        help_items+=("  start          Start a service")
        help_items+=("  stop           Stop a service")
        help_items+=("  restart        Restart a service")
        help_items+=("  reload         Reload config and restart")
        help_items+=("  status         Show service status")
        help_items+=("  list           List all services")
        help_items+=("  logs           Show logs / rotate subcommand")
        help_items+=("  prune          Clean stale state (dead pid by default)")
        help_items+=("  check          Static service checks")
        help_items+=("  log-rotate     Manually rotate logs (compat)")
        help_items+=("  install        Install ssm into bin")
        help_items+=("  enable         Enable service autostart")
        help_items+=("  disable        Disable service autostart")
        help_items+=("  help           Show help")
        help_items+=("")
        help_items+=("Get detailed help for a command:")
        help_items+=("  ${CURRENT_SCRIPT_NAME} help <command>")
        help_items+=("  ${CURRENT_SCRIPT_NAME} help all          Show help for all commands")
        help_items+=("  ${CURRENT_SCRIPT_NAME} help *            Same as above")
        help_items+=("  ${CURRENT_SCRIPT_NAME} help tree         Show command tree")
    fi
    
    msg_list "${help_items[@]}"
    
    return ${EXIT_SUCCESS}
}

# 内部函数：树状显示命令
function _show_command_tree_help() {
    local cmd_name
    cmd_name=$(get_default_command_name)

    local items=()
    if is_chinese; then
        items+=("${SSM_NAME} ${SSM_VERSION} 命令树")
        items+=("")
        items+=("${cmd_name}")
        items+=("├─ init")
        items+=("├─ create")
        items+=("├─ start")
        items+=("├─ stop")
        items+=("├─ restart")
        items+=("├─ reload")
        items+=("├─ status")
        items+=("├─ list")
        items+=("├─ logs")
        items+=("├─ log-rotate")
        items+=("├─ prune")
        items+=("├─ check")
        items+=("├─ install")
        items+=("├─ enable")
        items+=("├─ disable")
        items+=("└─ help")
        items+=("   ├─ help <command>")
        items+=("   ├─ help all")
        items+=("   └─ help tree")
    else
        items+=("${SSM_NAME} ${SSM_VERSION} command tree")
        items+=("")
        items+=("${cmd_name}")
        items+=("├─ init")
        items+=("├─ create")
        items+=("├─ start")
        items+=("├─ stop")
        items+=("├─ restart")
        items+=("├─ reload")
        items+=("├─ status")
        items+=("├─ list")
        items+=("├─ logs")
        items+=("├─ log-rotate")
        items+=("├─ prune")
        items+=("├─ check")
        items+=("├─ install")
        items+=("├─ enable")
        items+=("├─ disable")
        items+=("└─ help")
        items+=("   ├─ help <command>")
        items+=("   ├─ help all")
        items+=("   └─ help tree")
    fi

    msg_list "${items[@]}"
    return ${EXIT_SUCCESS}
}

# 内部函数：显示特定命令帮助
# 参数: $1 - 命令名
function _show_command_help() {
    local command="$1"
    local help_items=()
    
    case "$command" in
        init)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} init")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  初始化 SSM，创建必要的目录结构和配置文件")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} init [--force]")
                help_items+=("")
                help_items+=("选项:")
                help_items+=("  --force    强制重新初始化（覆盖现有配置）")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} init")
                help_items+=("  ${CURRENT_SCRIPT_NAME} init --force")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} init")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Initialize SSM, create necessary directory structure and configuration files")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} init [--force]")
                help_items+=("")
                help_items+=("Options:")
                help_items+=("  --force    Force reinitialization (overwrite existing configuration)")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} init")
                help_items+=("  ${CURRENT_SCRIPT_NAME} init --force")
            fi
            ;;
            
        create)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} create")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  创建新服务")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} create <service_name> [-cc|-cl] [--start-sh-in <link|source>]")
                help_items+=("")
                help_items+=("选项:")
                help_items+=("  -cc        复制当前目录内容到服务目录")
                help_items+=("  -cl        创建符号链接到当前目录")
                help_items+=("  --start-sh-in <link|source>")
                help_items+=("            仅 -cl 可用，控制 start.sh 生成位置")
                help_items+=("            link=链接路径内(默认), source=源目录内")
                help_items+=("")
                help_items+=("服务名规则:")
                help_items+=("  - 只能包含字母、数字、连字符、下划线")
                help_items+=("  - 不能以点开头")
                help_items+=("  - 不能包含斜杠或空格")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} create my-app")
                help_items+=("  ${CURRENT_SCRIPT_NAME} create my-app -cc")
                help_items+=("  ${CURRENT_SCRIPT_NAME} create my-app -cl")
                help_items+=("  ${CURRENT_SCRIPT_NAME} create my-app -cl --start-sh-in source")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} create")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Create a new service")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} create <service_name> [-cc|-cl] [--start-sh-in <link|source>]")
                help_items+=("")
                help_items+=("Options:")
                help_items+=("  -cc        Copy current directory content to service directory")
                help_items+=("  -cl        Create symbolic link to current directory")
                help_items+=("  --start-sh-in <link|source>")
                help_items+=("            Only for -cl, controls where start.sh is created")
                help_items+=("            link=inside linked path (default), source=inside source dir")
                help_items+=("")
                help_items+=("Service Name Rules:")
                help_items+=("  - Only letters, numbers, hyphens, underscores allowed")
                help_items+=("  - Cannot start with a dot")
                help_items+=("  - Cannot contain slashes or spaces")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} create my-app")
                help_items+=("  ${CURRENT_SCRIPT_NAME} create my-app -cc")
                help_items+=("  ${CURRENT_SCRIPT_NAME} create my-app -cl")
                help_items+=("  ${CURRENT_SCRIPT_NAME} create my-app -cl --start-sh-in source")
            fi
            ;;
            
        start)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} start")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  启动指定服务，支持双生子服务和命令行环境变量")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start <service_name> [-e <env>] [<twin_env>]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start [-e <env>] [<twin_env>] <service_name>")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start <service_name> --depends <svc> <running|stopped|dead>")
                help_items+=("")
                help_items+=("选项:")
                help_items+=("  -e, --env <env_string> [<twin_env_string>]")
                help_items+=("      设置命令行环境变量")
                help_items+=("      第一个参数用于主服务")
                help_items+=("      第二个参数（可选）用于伴生服务")
                help_items+=("      格式: ENV1=\"value1\" ENV2=\"value2\"")
                help_items+=("")
                help_items+=("      使用 -e '' 清空已保存的环境变量")
                help_items+=("  --depends <service> <running|stopped|dead>")
                help_items+=("      仅当 depends 条件满足时才执行 start")
                help_items+=("      仅允许在 CLI 直接执行，不允许脚本调用")
                help_items+=("  --i-don-t-care-about-anything")
                help_items+=("      跳过 --depends 的所有检查并强制继续")
                help_items+=("")
                help_items+=("说明:")
                help_items+=("  - 环境变量会被保存到 .ssm.env，下次 start/restart 时自动复用")
                help_items+=("  - 如果不指定 -e，会自动读取并复用上次保存的环境变量")
                help_items+=("  - 使用 -e '' 清空已保存的环境变量")
                help_items+=("  - 使用 reload 命令可忽略并清除保存的环境变量")
                help_items+=("  - 命令行环境变量会覆盖配置文件中的同名变量")
                help_items+=("  - 服务内部使用什么变量名由服务自己决定（如 PORT、DEBUG 等）")
                help_items+=("")
                help_items+=("双生子机制:")
                help_items+=("  如果服务配置了双生子（SSM_TWIN），将按配置的顺序启动主服务和伴生服务")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start my-app")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start my-app --env 'PORT=8080 DEBUG=true'")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start my-app --env 'PORT=8080' 'PORT=8081'")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start my-app --env 'SERVER_PORT=8080' 'WORKER_PORT=3000'")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start --env 'PORT=8080' my-app")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start my-app --env ''")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} start")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Start specified service, supports twin services and command-line env vars")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start <service_name> [-e <env>] [<twin_env>]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start [-e <env>] [<twin_env>] <service_name>")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start <service_name> --depends <svc> <running|stopped|dead>")
                help_items+=("")
                help_items+=("Options:")
                help_items+=("  -e, --env <env_string> [<twin_env_string>]")
                help_items+=("      Set command-line environment variables")
                help_items+=("      First argument for main service")
                help_items+=("      Second argument (optional) for twin service")
                help_items+=("      Format: ENV1=\"value1\" ENV2=\"value2\"")
                help_items+=("")
                help_items+=("      Use -e '' to clear saved environment variables")
                help_items+=("  --depends <service> <running|stopped|dead>")
                help_items+=("      Execute start only when depends condition matches")
                help_items+=("      CLI direct execution only, scripted usage is denied")
                help_items+=("  --i-don-t-care-about-anything")
                help_items+=("      Skip all --depends checks and force continue")
                help_items+=("")
                help_items+=("Notes:")
                help_items+=("  - Env vars are saved to .ssm.env, auto-reused on next start/restart")
                help_items+=("  - Without -e, previously saved env vars will be automatically loaded")
                help_items+=("  - Use -e '' to clear saved environment variables")
                help_items+=("  - Use reload command to ignore and clear saved env vars")
                help_items+=("  - Command-line env vars override same-named vars from config file")
                help_items+=("  - Variable names are determined by each service (e.g., PORT, DEBUG)")
                help_items+=("")
                help_items+=("Twin Mechanism:")
                help_items+=("  If twin is configured, main and twin services will start in configured order")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start my-app")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start my-app --env 'PORT=8080 DEBUG=true'")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start my-app --env 'PORT=8080' 'PORT=8081'")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start my-app --env 'SERVER_PORT=8080' 'WORKER_PORT=3000'")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start --env 'PORT=8080' my-app")
                help_items+=("  ${CURRENT_SCRIPT_NAME} start my-app --env ''")
            fi
            ;;
            
        stop)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} stop")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  停止指定服务")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} stop <service_name> [--depends <svc> <running|stopped|dead>]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} stop <service_name> --depends <svc> <running|stopped|dead> --i-don-t-care-about-anything")
                help_items+=("")
                help_items+=("说明:")
                help_items+=("  - 不会删除 .ssm.env 文件，环境变量配置会被保留")
                help_items+=("  - 如果配置了 SSM_TWIN_STOP_TOGETHER=true，将同时停止伴生服务")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} stop my-app")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} stop")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Stop specified service")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} stop <service_name>")
                help_items+=("")
                help_items+=("Notes:")
                help_items+=("  - Does not remove .ssm.env file, env var config is preserved")
                help_items+=("  - If SSM_TWIN_STOP_TOGETHER=true, twin service will also be stopped")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} stop my-app")
            fi
            ;;
            
        restart)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} restart")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  重启指定服务（先停止再启动）")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart <service_name> [-e <env>] [<twin_env>] [--depends <svc> <running|stopped|dead>]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart [-e <env>] [<twin_env>] <service_name>")
                help_items+=("")
                help_items+=("选项:")
                help_items+=("  -e, --env <env_string> [<twin_env_string>]")
                help_items+=("      设置命令行环境变量（同 start 命令）")
                help_items+=("  --depends <service> <running|stopped|dead>")
                help_items+=("      仅当 depends 条件满足时才执行 restart")
                help_items+=("  --i-don-t-care-about-anything")
                help_items+=("      跳过 --depends 的所有检查并强制继续")
                help_items+=("")
                help_items+=("说明:")
                help_items+=("  - 如果不指定 -e，会自动复用上次保存的环境变量")
                help_items+=("  - 指定新的 -e 会覆盖并更新保存的环境变量")
                help_items+=("  - 使用 -e '' 清空已保存的环境变量")
                help_items+=("  - 使用 reload 命令可忽略并清除保存的环境变量")
                help_items+=("")
                help_items+=("注意:")
                help_items+=("  - 指定新的 -e 参数会完全覆盖之前保存的环境变量")
                help_items+=("  - 如果服务有双生子，需要同时指定两个参数")
                help_items+=("  - 例如：restart main --env 'PORT=3000' 'PORT=3001'")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart my-app")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart my-app --env 'PORT=9090'")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart my-app --env 'PORT=8080' 'PORT=8081'")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart my-app --env ''")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart --env 'PORT=8080' my-app")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} restart")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Restart specified service (stop then start)")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart <service_name> [-e <env>] [<twin_env>] [--depends <svc> <running|stopped|dead>]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart [-e <env>] [<twin_env>] <service_name>")
                help_items+=("")
                help_items+=("Options:")
                help_items+=("  -e, --env <env_string> [<twin_env_string>]")
                help_items+=("      Set command-line environment variables (same as start command)")
                help_items+=("  --depends <service> <running|stopped|dead>")
                help_items+=("      Execute restart only when depends condition matches")
                help_items+=("  --i-don-t-care-about-anything")
                help_items+=("      Skip all --depends checks and force continue")
                help_items+=("")
                help_items+=("Notes:")
                help_items+=("  - Without -e, previously saved env vars will be automatically reused")
                help_items+=("  - Specifying new -e will override and update saved env vars")
                help_items+=("  - Use -e '' to clear saved environment variables")
                help_items+=("  - Use reload command to ignore and clear saved env vars")
                help_items+=("")
                
                help_items+=("Attention:")
                help_items+=("  - Specifying new -e completely overwrites previously saved env vars")
                help_items+=("  - If service has twin, need to specify both parameters")
                help_items+=("  - Example: restart main --env 'PORT=3000' 'PORT=3001'")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart my-app")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart my-app --env 'PORT=9090'")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart my-app --env 'PORT=8080' 'PORT=8081'")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart my-app --env ''")
                help_items+=("  ${CURRENT_SCRIPT_NAME} restart --env 'PORT=8080' my-app")
            fi
            ;;
            
        reload)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} reload")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  重新加载服务配置并重启")
                help_items+=("  清除所有保存的命令行环境变量")
                help_items+=("  服务将只使用配置文件中的环境变量")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} reload <service_name> [--depends <svc> <running|stopped|dead>]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} reload <service_name> --depends <svc> <running|stopped|dead> --i-don-t-care-about-anything")
                help_items+=("")
                help_items+=("说明:")
                help_items+=("  - 不接受 -e/--env 参数")
                help_items+=("  - 会删除保存的 .ssm.env 文件")
                help_items+=("  - 重新读取 .ssm.conf 配置文件")
                help_items+=("  - 适用于需要\"回到初始状态\"的场景")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} reload my-app")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} reload")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Reload service configuration and restart")
                help_items+=("  Clear all saved command-line environment variables")
                help_items+=("  Service will only use environment variables from config file")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} reload <service_name> [--depends <svc> <running|stopped|dead>]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} reload <service_name> --depends <svc> <running|stopped|dead> --i-don-t-care-about-anything")
                help_items+=("")
                help_items+=("Notes:")
                help_items+=("  - Does not accept -e/--env option")
                help_items+=("  - Will delete saved .ssm.env file")
                help_items+=("  - Re-read .ssm.conf configuration file")
                help_items+=("  - Useful for \"back to initial state\" scenarios")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} reload my-app")
            fi
            ;;
            
        status)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} status")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  查看服务状态")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} status [service_name]")
                help_items+=("")
                help_items+=("参数:")
                help_items+=("  无参数时显示所有服务状态列表")
                help_items+=("  指定服务名时显示该服务的详细状态")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} status")
                help_items+=("  ${CURRENT_SCRIPT_NAME} status my-app")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} status")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Show service status")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} status [service_name]")
                help_items+=("")
                help_items+=("Arguments:")
                help_items+=("  Without arguments, show status of all services")
                help_items+=("  With service name, show detailed status of that service")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} status")
                help_items+=("  ${CURRENT_SCRIPT_NAME} status my-app")
            fi
            ;;
            
        list)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} list")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  列出所有服务及其状态")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} list")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} list")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} list")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  List all services and their status")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} list")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} list")
            fi
            ;;

        logs)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} logs")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  查看日志，支持 tail/head，支持后端选择")
                help_items+=("  子命令 rotate 等价于 log-rotate")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} logs <service|manager|history> [--mode tail|head] [--lines N] [--backend auto|native|sed] [--type out|err]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} logs rotate")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} logs")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Show logs with tail/head and backend selection")
                help_items+=("  Subcommand rotate equals log-rotate")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} logs <service|manager|history> [--mode tail|head] [--lines N] [--backend auto|native|sed] [--type out|err]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} logs rotate")
            fi
            ;;
            
        log-rotate)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} log-rotate")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  手动执行日志轮转，清理过期日志")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} log-rotate")
                help_items+=("")
                help_items+=("处理内容:")
                help_items+=("  - 轮转管理器日志")
                help_items+=("  - 轮转历史日志")
                help_items+=("  - 轮转所有服务日志")
                help_items+=("  - 清理过期日志")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} log-rotate")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} log-rotate")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Manually rotate logs and clean up old logs")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} log-rotate")
                help_items+=("")
                help_items+=("What it does:")
                help_items+=("  - Rotate manager log")
                help_items+=("  - Rotate history log")
                help_items+=("  - Rotate all service logs")
                help_items+=("  - Clean up old logs")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} log-rotate")
            fi
            ;;

        prune)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} prune")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  清理陈旧状态；默认仅清理 dead pid")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} prune <service...>")
                help_items+=("  ${CURRENT_SCRIPT_NAME} prune --all")
                help_items+=("  ${CURRENT_SCRIPT_NAME} prune <service...> [--env] [--logs]")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} prune")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Clean stale state; dead pid only by default")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} prune <service...>")
                help_items+=("  ${CURRENT_SCRIPT_NAME} prune --all")
                help_items+=("  ${CURRENT_SCRIPT_NAME} prune <service...> [--env] [--logs]")
            fi
            ;;

        check)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} check")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  对服务进行静态检查（不启动服务）")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} check <service...>")
                help_items+=("  ${CURRENT_SCRIPT_NAME} check --all")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} check")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Run static checks for services (no start/stop)")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} check <service...>")
                help_items+=("  ${CURRENT_SCRIPT_NAME} check --all")
            fi
            ;;

        install)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} install")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  安装当前脚本到 bin 目录并赋予可执行权限")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} install [--dir <path>] [--name <name>]")
                help_items+=("")
                help_items+=("选项:")
                help_items+=("  --dir <path>    安装目录（默认: ~/.local/bin）")
                help_items+=("  --name <name>   安装文件名（默认: ssm）")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} install")
                help_items+=("  ${CURRENT_SCRIPT_NAME} install --dir ~/bin --name ssm")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} install")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Install current script into bin directory and set executable permission")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} install [--dir <path>] [--name <name>]")
                help_items+=("")
                help_items+=("Options:")
                help_items+=("  --dir <path>    Install directory (default: ~/.local/bin)")
                help_items+=("  --name <name>   Installed filename (default: ssm)")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} install")
                help_items+=("  ${CURRENT_SCRIPT_NAME} install --dir ~/bin --name ssm")
            fi
            ;;

        enable)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} enable")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  启用服务自动启动（写入 .ssm/enabled.sh）")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} enable <service_name>")
                help_items+=("")
                help_items+=("说明:")
                help_items+=("  - 启用列表脚本: ~/.services/.ssm/enabled.sh")
                help_items+=("  - 在 chroot/proot 环境下会提示选择 shell 启动文件")
                help_items+=("  - 可手动编辑服务的 .ssm.conf 调整启动行为")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} enable")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Enable service autostart (stored in .ssm/enabled.sh)")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} enable <service_name>")
                help_items+=("")
                help_items+=("Notes:")
                help_items+=("  - Enabled script: ~/.services/.ssm/enabled.sh")
                help_items+=("  - In chroot/proot, it will ask you which shell startup file to use")
                help_items+=("  - You can edit service .ssm.conf to tune startup behavior")
            fi
            ;;

        disable)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} disable")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  禁用服务自动启动（从 .ssm/enabled.sh 移除）")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} disable <service_name>")
                help_items+=("")
                help_items+=("说明:")
                help_items+=("  - 若无任何启用服务，会自动移除 shell 启动钩子")
                help_items+=("  - 可手动编辑服务的 .ssm.conf 调整启动行为")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} disable")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Disable service autostart (remove from .ssm/enabled.sh)")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} disable <service_name>")
                help_items+=("")
                help_items+=("Notes:")
                help_items+=("  - If no service is enabled, shell startup hook will be removed automatically")
                help_items+=("  - You can edit service .ssm.conf to tune startup behavior")
            fi
            ;;
            
        help)
            if is_chinese; then
                help_items+=("命令: ${CURRENT_SCRIPT_NAME} help")
                help_items+=("")
                help_items+=("描述:")
                help_items+=("  显示帮助信息")
                help_items+=("")
                help_items+=("用法:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help [command]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help all")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help *")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help tree")
                help_items+=("")
                help_items+=("参数:")
                help_items+=("  无参数时显示总体帮助")
                help_items+=("  指定命令名时显示该命令的详细帮助")
                help_items+=("  使用 all 或 * 显示所有命令的详细帮助")
                help_items+=("  使用 tree 显示命令树")
                help_items+=("")
                help_items+=("示例:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help start")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help all")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help tree")
            else
                help_items+=("Command: ${CURRENT_SCRIPT_NAME} help")
                help_items+=("")
                help_items+=("Description:")
                help_items+=("  Show help information")
                help_items+=("")
                help_items+=("Usage:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help [command]")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help all")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help *")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help tree")
                help_items+=("")
                help_items+=("Arguments:")
                help_items+=("  Without arguments, show general help")
                help_items+=("  With command name, show detailed help for that command")
                help_items+=("  Use 'all' or '*' to show detailed help for all commands")
                help_items+=("  Use 'tree' to show command tree")
                help_items+=("")
                help_items+=("Examples:")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help start")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help all")
                help_items+=("  ${CURRENT_SCRIPT_NAME} help tree")
            fi
            ;;
            
        *)
            msg_error "未知命令: ${command}" "Unknown command: ${command}"
            msg_info "使用 '${CURRENT_SCRIPT_NAME} help' 查看可用命令" "Use '${CURRENT_SCRIPT_NAME} help' to see available commands"
            return ${EXIT_USAGE}
            ;;
    esac
    
    msg_list "${help_items[@]}"
    
    return ${EXIT_SUCCESS}
}

# 内部函数：显示所有命令的详细帮助
function _show_all_commands_help() {
    local commands=("init" "create" "start" "stop" "restart" "reload" "status" "list" "logs" "log-rotate" "prune" "check" "install" "enable" "disable" "help")
    
    for cmd in "${commands[@]}"; do
        _show_command_help "$cmd"
        echo ""
        msg_separator
        echo ""
    done
    
    return ${EXIT_SUCCESS}
}

# ═══════════════════════════════════════════════════════════════════════════
# 命令路由
# ═══════════════════════════════════════════════════════════════════════════

function route_command() {
    local command="$1"
    shift

    local handler

    # 需要按指定身份执行时，使用 su -c 包一层
    if [[ -z "${SSM_RUN_AS_ACTIVE:-}" ]] && [[ -n "$SSM_RUN_AS_USER" ]] && [[ "$SSM_RUN_AS_USER" != "$SSM_CURRENT_USER" ]]; then
        local cmdline
        cmdline=$(build_shell_command_quoted "env" "SSM_RUN_AS_ACTIVE=1" "$0" -u "$SSM_TARGET_USER" "$command" "$@")
        su "$SSM_RUN_AS_USER" -c "$cmdline"
        return $?
    fi

    if handler=$(get_command_handler "$command"); then
        "$handler" "$@"
        return $?
    fi

    msg_error "未知命令: $command" "Unknown command: $command"
    msg_info "使用 '$CURRENT_SCRIPT_NAME help' 查看帮助" "Use '$CURRENT_SCRIPT_NAME help' for help"
    return ${EXIT_USAGE}
}


# ═══════════════════════════════════════════════════════════════════════════
# 主入口
# ═══════════════════════════════════════════════════════════════════════════

# 清理所有持有的锁
function cleanup_all_locks() {
    for service_name in "${!SSM_LOCK_FDS[@]}"; do
        release_service_lock "$service_name" 2>/dev/null || true
    done
}

# 在主入口添加 trap
function main() {
    local target_user=""
    local run_as_user=""
    local command=""
    
    # 【修复】设置 trap 确保异常退出时释放锁
    trap cleanup_all_locks EXIT INT TERM
    
    # 解析全局选项
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -u|--user)
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 -u/--user 需要参数" "Option -u/--user requires an argument"
                    return ${EXIT_USAGE}
                fi
                target_user="$2"
                shift 2
                ;;
            -r|--run-as)
                if [[ $# -lt 2 ]]; then
                    msg_error "选项 -r/--run-as 需要参数" "Option -r/--run-as requires an argument"
                    return ${EXIT_USAGE}
                fi
                run_as_user="$2"
                shift 2
                ;;
            -h|--help)
                cmd_help
                return ${EXIT_SUCCESS}
                ;;
            -v|--version)
                echo "${SSM_NAME} ${SSM_VERSION}"
                return ${EXIT_SUCCESS}
                ;;
            -*)
                msg_error "未知选项: $1" "Unknown option: $1"
                return ${EXIT_USAGE}
                ;;
            *)
                command="$1"
                shift
                break
                ;;
        esac
    done
    
    # 检查是否提供了命令
    if [[ -z "$command" ]]; then
        msg_error "缺少命令" "Missing command"
        msg_info "使用 '${CURRENT_SCRIPT_NAME} help' 查看帮助" "Use '${CURRENT_SCRIPT_NAME} help' for help"
        return ${EXIT_USAGE}
    fi
    
    # 初始化目标用户环境
    init_target_user "$target_user"

    # 加载全局配置（用于读取默认 run-as）
    load_global_config

    # run-as 优先级：命令行 > 配置 > 当前用户
    if [[ -z "$run_as_user" ]]; then
        run_as_user="${SSM_GLOBAL_CONFIG[SSM_RUN_AS]}"
    fi
    if [[ -z "$run_as_user" ]]; then
        run_as_user="$SSM_CURRENT_USER"
    fi

    if ! user_exists "$run_as_user"; then
        msg_error "执行用户不存在: ${run_as_user}" "Run-as user does not exist: ${run_as_user}"
        return ${EXIT_USAGE}
    fi
    SSM_RUN_AS_USER="$run_as_user"
    
    # 初始化 UI 框架的颜色设置
    MSG_COLOR="${SSM_GLOBAL_CONFIG[SSM_COLOR]}"
    MSG_LIST_SEPARATOR="line"
    
    # 路由命令
    route_command "$command" "$@"
}

# ═══════════════════════════════════════════════════════════════════════════
# 执行主函数
# ═══════════════════════════════════════════════════════════════════════════

# 只有在直接执行脚本时才运行 main
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
    exit $?
fi
